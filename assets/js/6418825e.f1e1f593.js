"use strict";(self.webpackChunk_rnx_kit_docsite=self.webpackChunk_rnx_kit_docsite||[]).push([[8410],{66:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var s=a(4848),n=a(8453);const o={},i="tools-packages",c={id:"tools/tools-packages",title:"tools-packages",description:"Build",source:"@site/docs/tools/tools-packages.md",sourceDirName:"tools",slug:"/tools/tools-packages",permalink:"/rnx-kit/docs/tools/tools-packages",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/rnx-kit/tree/main/docsite/docs/tools/tools-packages.md",tags:[],version:"current",frontMatter:{},sidebar:"toolsSidebar",previous:{title:"tools-node",permalink:"/rnx-kit/docs/tools/tools-node"},next:{title:"tools-react-native",permalink:"/rnx-kit/docs/tools/tools-react-native"}},r={},d=[{value:"Motivation",id:"motivation",level:2},{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Types",id:"types",level:3},{value:"Functions",id:"functions",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"tools-packages",children:"tools-packages"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://github.com/microsoft/rnx-kit/actions/workflows/build.yml",children:(0,s.jsx)(t.img,{src:"https://github.com/microsoft/rnx-kit/actions/workflows/build.yml/badge.svg",alt:"Build"})}),"\n",(0,s.jsx)(t.a,{href:"https://www.npmjs.com/package/@rnx-kit/tools-packages",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/npm/v/@rnx-kit/tools-packages",alt:"npm version"})})]}),"\n",(0,s.jsxs)(t.p,{children:["This package has utilities for loading base information about packages,\nretrieved in a ",(0,s.jsx)(t.code,{children:"PackageInfo"})," type, with a layer of caching that happens\nautomatically, as well as the ability to store additional custom values in the\nretrieved ",(0,s.jsx)(t.code,{children:"PackageInfo"})]}),"\n",(0,s.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(t.p,{children:"While loading package.json is pretty quick, this can quickly end up being a\nredundant operation as there different packages in rnx-kit all need different\ninformation from the file. This adds a simple caching layer for retrieving\npackages so work is not done multiple times."}),"\n",(0,s.jsxs)(t.p,{children:["The packages can also have custom accessors defined that allow storing of\nadditional data in the ",(0,s.jsx)(t.code,{children:"PackageInfo"})," and because of that, associated with that\npackage in the cache. This might be loading the ",(0,s.jsx)(t.code,{children:"KitConfig"})," parsing and\nvalidating a tsconfig.json file. This package doesn't need to care what is being\nstored, other packages can add their custom accessors as needed."]}),"\n",(0,s.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"yarn add @rnx-kit/tools-packages --dev\n"})}),"\n",(0,s.jsx)(t.p,{children:"or if you're using npm"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"npm add --save-dev @rnx-kit/tools-packages\n"})}),"\n",(0,s.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(t.p,{children:"There are two main parts of this package, helpers for retrieving package info\nand helpers for accessors."}),"\n",(0,s.jsx)(t.h3,{id:"types",children:"Types"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Type Name"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PlatformInfo"})}),(0,s.jsxs)(t.td,{children:["Main returned type for the module. This contains information about the package name, root package path, the loaded package.json in ",(0,s.jsx)(t.code,{children:"Manifest"})," form, whether or not the package is a workspace, as well as a ",(0,s.jsx)(t.code,{children:"symbol"})," based index signature for attaching additional information to the type."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"GetPackageValue<T>"})}),(0,s.jsx)(t.td,{children:"Format for a value accessor, used when creating accessors that only need to be loaded once."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PackageValueAccessors<T>"})}),(0,s.jsxs)(t.td,{children:["Typed has/get/set methods to access values attached to the ",(0,s.jsx)(t.code,{children:"PackageInfo"})," when they may be updated."]})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"functions",children:"Functions"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Function"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"getPackageInfoFromPath"})}),(0,s.jsxs)(t.td,{children:["Given a path to either the root folder of a package, or the package.json for that package, return a loaded ",(0,s.jsx)(t.code,{children:"PackageInfo"})," for that package. This will attempt to look up the package in the cache, loading it if not found. It will throw an exception on an invalid path."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"getPackageInfoFromWorkspaces"})}),(0,s.jsxs)(t.td,{children:["Try to retrieve a ",(0,s.jsx)(t.code,{children:"PackageInfo"})," by name. This only works for in-workspace packages as module resolution outside of that scope is more complicated. Note that by default this only finds packages previously cached. If the optional boolean parameter is set to true, in the case that the package is not found, all workspaces will be loaded into the cache. This can be expensive though it is a one time cost."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"getRootPackageInfo"})}),(0,s.jsx)(t.td,{children:"Get the package info for the root of the workspaces"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"createPackageValueLoader<T>"})}),(0,s.jsxs)(t.td,{children:["Create a function which retrieves a cached value from ",(0,s.jsx)(t.code,{children:"PackageInfo"})," calling the initializer function if it hasn't been loaded yet. This creates an internal symbol for to make the access unique with the supplied friendly name to make debugging easier."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"createPackageValueAccessors"})}),(0,s.jsx)(t.td,{children:"Create three typed functions matching the has/get/set signature associated with a new and contained symbol. This is for accessors that may need to change over time."})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>c});var s=a(6540);const n={},o=s.createContext(n);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);