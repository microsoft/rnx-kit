"use strict";(self.webpackChunk_rnx_kit_docsite=self.webpackChunk_rnx_kit_docsite||[]).push([[114],{2545:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"dependencies","title":"Dependencies","description":"The React Native ecosystem is vast, and it changes all the time. This makes it","source":"@site/docs/dependencies.md","sourceDirName":".","slug":"/dependencies","permalink":"/rnx-kit/docs/dependencies","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/rnx-kit/tree/main/docsite/docs/dependencies.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Introduction","permalink":"/rnx-kit/docs/introduction"},"next":{"title":"Type Safety","permalink":"/rnx-kit/docs/type-safety"}}');var t=a(4848),s=a(8453);const c={},r="Dependencies",o={},d=[{value:"Capabilities and Profiles",id:"capabilities-and-profiles",level:2},{value:"Meta Capabilities",id:"meta-capabilities",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Validating Dependencies",id:"validating-dependencies",level:2},{value:"Updating Dependencies",id:"updating-dependencies",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"dependencies",children:"Dependencies"})}),"\n",(0,t.jsxs)(n.p,{children:["The React Native ecosystem is vast, and it changes all the time. This makes it\nhard to find ",(0,t.jsx)(n.strong,{children:"actively maintained"})," packages which are ",(0,t.jsx)(n.strong,{children:"compatible"})," with each\nother, and with the React Native version you are using. Keeping up means regular\npackage.json maintenance and thorough compatibility testing."]}),"\n",(0,t.jsx)(n.p,{children:"When you're ready to upgrade React Native itself, you need to start the whole\nprocess over again. Find a new set of package versions. Make sure they don't\nbreak each other or your app. It's a never-ending, time-consuming cycle."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/guides/dependency-management",children:"dependency manager"})," solves these\nproblems. It knows which React Native package versions work well together, and\nit uses that knowledge to keep your app healthy and up-to-date."]}),"\n",(0,t.jsx)(n.h2,{id:"capabilities-and-profiles",children:"Capabilities and Profiles"}),"\n",(0,t.jsxs)(n.p,{children:["The magic is in the data that comes with the dependency manager -- capabilities\nand profiles. Together, they describe a ",(0,t.jsx)(n.em,{children:"curated"})," and ",(0,t.jsx)(n.em,{children:"tested"})," list of packages\nthat work with each major release of React Native; you can find the full list of\ncapabilities (",(0,t.jsx)(n.em,{children:"name & corresponding package"}),") that are supported by default\n",(0,t.jsx)(n.a,{href:"https://github.com/microsoft/rnx-kit/tree/main/packages/align-deps#capabilities",children:"in this table"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"A capability is something your app needs to function. It has a well-known name,\nand it maps to a specific package and version:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const capability = {\n  react: {\n    name: "react",\n    version: "17.0.2",\n  },\n};\n'})}),"\n",(0,t.jsx)(n.p,{children:"Capabilities can depend on each other, creating a tree:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const capabilities = {\n  react: {\n    name: "react",\n    version: "17.0.2",\n  },\n  "react-dom": {\n    name: "react-dom",\n    version: "17.0.2",\n    capabilities: ["react"],\n  },\n};\n'})}),"\n",(0,t.jsx)(n.p,{children:"A profile is a collection of capabilities, known to work well with a specific\nrelease of React Native:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const reactNative: Package = {\n  name: "react-native",\n  version: "^0.68.0",\n  capabilities: ["react"],\n};\n\nconst profile_0_68: Profile = {\n  react: {\n    name: "react",\n    version: "17.0.2",\n  },\n  core: reactNative,\n  "core-android": reactNative,\n  "core-ios": reactNative,\n  // ... etc ...\n};\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Each React Native release >= 0.61 has its own\n",(0,t.jsx)(n.a,{href:"https://github.com/microsoft/rnx-kit/blob/main/packages/align-deps/src/presets/microsoft/react-native.ts",children:"base profile"}),",\nand you can tailor your local configuration by following this\n",(0,t.jsx)(n.a,{href:"/docs/guides/dependency-management#customization",children:"customization guide"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"meta-capabilities",children:"Meta Capabilities"}),"\n",(0,t.jsx)(n.p,{children:"Meta capabilities let you group capabilities together:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'{\n  "core/all": {\n    name: "#meta",\n    capabilities: [\n      "core-android",\n      "core-ios",\n      "core-macos",\n      "core-visionos",\n      "core-windows",\n    ],\n  },\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Meta capabilities aren't versioned, and always have ",(0,t.jsx)(n.code,{children:"#meta"})," in the name\nproperty."]}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["A package tells the dependency manager about itself using configuration. It\nanswers questions such as: Is the package an ",(0,t.jsx)(n.code,{children:"app"})," or a ",(0,t.jsx)(n.code,{children:"library"}),"? Which\nversion(s) of React Native is the package targeting? What capabilities does the\npackage require?"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:"title=package.json",children:'{\n  "rnx-kit": {\n    "kitType": "app",\n    "alignDeps": {\n      "requirements": ["react-native@0.68"],\n      "capabilities": [\n        "core-android",\n        "core-ios",\n        "core-macos",\n        "core-visionos",\n        "core-windows",\n        "react",\n        "test-app"\n      ]\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The dependency manager uses this configuration when validating or updating the\npackage's dependency list."}),"\n",(0,t.jsx)(n.h2,{id:"validating-dependencies",children:"Validating Dependencies"}),"\n",(0,t.jsxs)(n.p,{children:["The dependency manager scans a package's dependencies, reporting anything that\nis incompatible or missing. It normally only validates ",(0,t.jsx)(n.em,{children:"configured"})," packages,\nthough it can be used to validate unconfigured packages."]}),"\n",(0,t.jsxs)(n.p,{children:["Configured package validation starts with the target React Native version(s).\nThe dependency manager gets the corresponding profile(s) and cross-references\nthem with the package's capabilities. Now it knows which dependencies (and\nversions) the package ",(0,t.jsx)(n.em,{children:"should"})," have. It checks ",(0,t.jsx)(n.code,{children:"dependencies"}),",\n",(0,t.jsx)(n.code,{children:"devDependencies"}),", and ",(0,t.jsx)(n.code,{children:"peerDependencies"}),", looking for incompatible or missing\npackages. If anything is wrong, it reports detailed information to the console."]}),"\n",(0,t.jsx)(n.p,{children:"Validating an unconfigured package isn't as precise, though it is very useful as\na transitional tool when on-boarding large monorepos. You tell the dependency\nmanager which React Native version(s) to target. It looks at the package's\ndependencies, and reverse-maps them to known capabilities. From there, it can\nvalidate using the inferred capability list, reporting any incompatible or\nmissing dependencies."}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.a,{href:"/docs/guides/dependency-management",children:"dependency manager guide"})," to learn\nhow to on-board existing repos incrementally, and run validation on configured\nand unconfigured packages."]}),"\n",(0,t.jsx)(n.h2,{id:"updating-dependencies",children:"Updating Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"The dependency manager can automatically update a package's dependencies,\nresolving compatibility problems and adding missing dependencies."}),"\n",(0,t.jsx)(n.p,{children:"This is a very powerful tool for developers, especially when used in monorepos\nwith many packages."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/guides/dependency-management",children:"dependency manager guide"})," shows you how\nto keep your packages up-to-date as dependencies change or capabilities are\nadded/removed. It also shows you how to automate a React Native upgrade,\nchanging every package and its dependencies, to known/good versions that work\nwell together."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>r});var i=a(6540);const t={},s=i.createContext(t);function c(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);