# Copilot Instructions for rnx-kit

## Repository Overview

`rnx-kit` is a collection of battle-tested React Native tooling packages created
by Microsoft engineers to optimize the React Native developer experience. This
is a **monorepo** containing multiple packages organized under `packages/`
(stable tools) and `incubator/` (experimental tools).

## Project Structure

- **`packages/`** - Stable, production-ready tools and libraries
- **`incubator/`** - Experimental packages (use with caution)
- **`docsite/`** - Documentation website built with Docusaurus
- **`scripts/`** - Build and maintenance scripts
- **`test-repos/`** - Test repository configurations in a separate repository

## Key Packages and Their Purposes

### Core Tools

- **`align-deps`** - Dependency management and version alignment across large
  projects
- **`cli`** - All-in-one command-line interface for rnx-kit tools
- **`config`** - Configuration management for rnx-kit tools
- **`console`** - Logging and console utilities

### Metro/Bundling Tools

- **`metro-config`** - Metro bundler configuration helpers
- **`metro-serializer`** - Enhanced Metro serializer with plugin support
- **`metro-serializer-esbuild`** - esbuild-powered Metro serializer for tree
  shaking
- **`metro-plugin-*`** - Various Metro plugins (TypeScript, cyclic deps,
  duplicates)

### TypeScript Tools

- **`typescript-service`** - TypeScript language service wrapper
- **`typescript-react-native-resolver`** - TypeScript module resolution for
  React Native
- **`tools-typescript`** (incubator) - Advanced TypeScript build tools

### Platform-Specific Tools

- **`tools-android`** - Android development utilities
- **`tools-apple`** - iOS/macOS development utilities
- **`tools-windows`** - Windows development utilities

### Developer Tools

- **`babel-preset-metro-react-native`** - Babel preset optimized for Metro
- **`eslint-config`** / **`eslint-plugin`** - ESLint configurations and rules
- **`jest-preset`** - Jest testing configuration
- **`dep-check`** - Dependency checking utilities

## Technology Stack

- **Language**: TypeScript (primary), JavaScript
- **Build System**: Nx (monorepo orchestration)
- **Package Manager**: Yarn version 4
- **Testing**: Jest with custom presets
- **Linting**: ESLint with custom configurations
- **Documentation**: Docusaurus
- **CI/CD**: GitHub Actions

## Development Guidelines

### Code Style

- Use TypeScript for all new code
- Follow existing ESLint configuration (`@rnx-kit/eslint-config`)
- Use consistent file naming (camelCase or kebab-case for files, PascalCase for
  classes)
- Include comprehensive JSDoc comments for public APIs

### Package Structure

Each package should follow this structure:

```
package-name/
├── src/           # Source code
├── lib/           # Compiled output (gitignored)
├── test/          # Test files
├── package.json   # Package configuration
├── README.md      # Package documentation
├── CHANGELOG.md   # Change history, generated by changesets
└── tsconfig.json  # TypeScript configuration
```

### Configuration Patterns

- Use `KitConfig` type for rnx-kit configuration
- Support both package.json and standalone config files
- Provide sensible defaults with override capabilities
- Use capability-based dependency management with presets

### Testing

- Write comprehensive unit tests for all public APIs
- Use fixtures in `test/__fixtures__/` for complex test scenarios
- Test both success and error cases
- Include integration tests for CLI tools
- Use node's `assert` module for testing simple packages, and Jest for more
  complex scenarios

### Dependencies

- Use `@rnx-kit/align-deps` to manage dependency versions
- Prefer peer dependencies for React Native packages
- Use workspace references (`workspace:*`) for internal dependencies
- Keep external dependencies minimal and well-justified

## Common Patterns

### Configuration Loading

```typescript
import { getKitConfig } from "@rnx-kit/config";

const config = getKitConfig({ cwd: projectRoot });
if (!config) {
  // Handle missing configuration
}
```

### Package Discovery

```typescript
import { findPackageInfo } from "@rnx-kit/tools-packages";
import { readPackage } from "@rnx-kit/tools-node/package";

const pkgInfo = findPackageInfo(targetPath);
const manifest = readPackage(manifestPath);
```

### File System Operations

```typescript
import { ensureDirForFile, writeTextFile } from "@rnx-kit/tools-filesystem";

// Ensure directory exists before writing a file
ensureDirForFile(filePath);
writeTextFile(filePath, "File content");
```

## Build and Development Commands

- `yarn` - Install dependencies
- `yarn build` - Build all packages
- `yarn test` - Run all tests
- `yarn lint` - Lint all packages
- `yarn format` - Format code
- `yarn new-package <name>` - Create new package
- `yarn rnx-align-deps` - Align dependencies across packages
- `yarn knip` - Run knip to check for unused exports

## Release Process

- Uses Changesets for version management
- `yarn change` - Add a changeset
- `yarn change:check` - Check changeset status
- `yarn publish:changesets` - Publish new versions

## Special Considerations

### React Native Compatibility

- Support multiple React Native versions through capability system
- Use platform-specific code paths when necessary
- Test against various React Native versions in CI

### Monorepo Management

- Use Nx for task orchestration and caching
- Maintain workspace references for internal dependencies
- Use `align-deps` to ensure version consistency

### Metro Integration

- Many tools integrate deeply with Metro bundler
- Understand Metro's plugin architecture
- Test with various Metro configurations

### Platform Support

- Support iOS, Android, macOS, Windows, and web platforms
- Use platform-specific tooling where appropriate
- Maintain cross-platform compatibility where possible

## Documentation

- Each package must have comprehensive README with usage examples
- Use JSDoc for API documentation
- CHANGELOG.md will be updated via changesets tool for all changes
- Contribute to main documentation site when adding new features

## When Contributing

1. Follow the existing code patterns and architecture
2. Add comprehensive tests for new functionality
3. Update documentation and changelogs
4. Use the align-deps tool to maintain dependency consistency
5. Consider backward compatibility and migration paths
6. Test across different React Native versions and platforms
