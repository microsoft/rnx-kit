/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-external-workspaces",
factory: function (require) {
"use strict";var plugin=(()=>{var Oe=Object.create;var E=Object.defineProperty;var Fe=Object.getOwnPropertyDescriptor;var Pe=Object.getOwnPropertyNames;var je=Object.getPrototypeOf,De=Object.prototype.hasOwnProperty;var l=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,o)=>(typeof require<"u"?require:e)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var R=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Se=(t,e)=>{for(var o in e)E(t,o,{get:e[o],enumerable:!0})},Q=(t,e,o,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Pe(e))!De.call(t,r)&&r!==o&&E(t,r,{get:()=>e[r],enumerable:!(n=Fe(e,r))||n.enumerable});return t};var b=(t,e,o)=>(o=t!=null?Oe(je(t)):{},Q(e||!t||!t.__esModule?E(o,"default",{value:t,enumerable:!0}):o,t)),_e=t=>Q(E({},"__esModule",{value:!0}),t);var N=R(f=>{"use strict";var Ee=f&&f.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(f,"__esModule",{value:!0});f.rebasePackageDefinition=Y;f.rebaseExternalDeps=Re;f.findDependencyChanges=$e;f.reportDependencyChanges=Ce;f.sortStringRecord=Te;var X=Ee(l("path"));function Y(t,e){return{path:t.path?X.default.posix.normalize(X.default.join(e,t.path)):null,version:t.version}}function Re(t,e){let o={};for(let n in t)o[n]=Y(t[n],e);return o}function be(t,e){return t.path===e.path&&t.version===e.version}function $e(t,e){let o={};for(let n in e)t[n]?be(t[n],e[n])||(o[n]="update"):o[n]="add";for(let n in t)e[n]||(o[n]="remove");return Object.keys(o).length>0?o:null}function Ce(t,e){for(let o in t){let n=String(t[o]).padEnd(6," ");e(`${n} - ${o}`)}}function Te(t,e){let o=Object.keys(t).sort();e??(e={});for(let n of o)e[n]=t[n];return e}});var ie=R(d=>{"use strict";var ee=d&&d.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(d,"__esModule",{value:!0});d.parseJsonPath=oe;d.getDepsFromJson=ne;d.createFinderFromJson=re;d.createFinderFromJs=se;d.loadExternalDeps=Le;var B=ee(l("fs")),S=ee(l("path")),We=N(),Z=".json",te=t=>null;function oe(t){let e=t.indexOf(Z);if(e>0){let o=e+Z.length,n=t.slice(0,o),r=t.length>o+1?t.slice(o+1):"";return{jsonPath:n,keysPath:r}}return{}}function ne(t,e){let o=e?e.split("/"):[],n=t;for(let r of o)if(n=n[r],!n)return;return n}function re(t,e,o){if(B.default.existsSync(t)){let n=ne(JSON.parse(B.default.readFileSync(t,"utf8")),e);if(n)return o(`Loaded the finder from the json file ${t}`),r=>n[r]??null}return te}function se(t,e){let o=l(t);if(!o)throw new Error(`Unable to load config from ${t}`);return e(`Creating a finder from: ${t}`),o.default}function Me(t,e,o,n){let r=new Map;return s=>{if(r.has(s))return r.get(s)??null;let a=t(s),i=a?{...a}:null;return i&&(i=(0,We.rebasePackageDefinition)(i,o),i.path&&(B.default.existsSync(S.default.join(e,i.path,"package.json"))?n(`finder: ${s} found at ${i.path}`):(n(`finder: ${s} not found at ${i.path}`),i.path=null))),r.set(s,i),i}}function Le(t,e,o){let n,r="";if(typeof t=="string"){if(S.default.isAbsolute(t))throw new Error(`Invalid external workspace config path: ${t}. Must be relative to the root of the repository`);let s=S.default.join(e,t);r=S.default.dirname(t);let{jsonPath:a,keysPath:i}=oe(s);if(a)n=re(a,i,o);else{let p=S.default.extname(s).toLowerCase();(p===".js"||p===".cjs")&&(n=se(s,o))}if(!n)throw new Error(`Invalid external workspace config path: ${s}. Supported types are .json, .js, and .cjs`)}else typeof t=="object"&&(n=s=>t[s]??null);return n?Me(n,e,r,o):te}});var le=R(y=>{"use strict";var ce=y&&y.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(y,"__esModule",{value:!0});y.externalWorkspacesKey=void 0;y.getExternalWorkspaces=Je;var k=ce(l("fs")),w=ce(l("path")),$=N(),z=ie(),ae=()=>null;y.externalWorkspacesKey="external-workspaces";var T=class t{constructor(e){this.startTime=performance.now(),this.root=e;let{outputOnlyOnCommand:o,outputPath:n,externalDependencies:r,logTo:s}=this.loadConfig(this.root);this.outputOnlyOnCommand=!!o,this.outputPath=n||"",this.logTo=s||"",this.trace=this.createTraceFunction(),this.report=a=>{console.log(a),this.trace(a)},this.findPackage=(0,z.loadExternalDeps)(r,e,this.trace)}outputWorkspaces(e,o,n){if(o??(o=this.outputPath),!o){this.trace("No output path specified, skipping write");return}let{jsonPath:r,keysPath:s}=(0,z.parseJsonPath)(w.default.join(this.root,o));if(r){let a=w.default.dirname(r);n||this.ensureDirExists(a);let i=w.default.relative(a,this.root),p=(0,$.rebaseExternalDeps)(e,i),c=k.default.existsSync(r)?JSON.parse(k.default.readFileSync(r,"utf8")):{},m=(0,z.getDepsFromJson)(c,s)||{},v=(0,$.findDependencyChanges)(m,p);if(v)if(n)this.report(`Update needed for ${o}:`),(0,$.reportDependencyChanges)(v,this.report);else{this.report(`Updating ${o}...`);let _=s?s.split("/"):[],G=_.length>0?c:{},j=G,D=_.shift();for(;D;)(!j[D]||_.length===0)&&(j[D]={}),j=j[D],D=_.shift();(0,$.sortStringRecord)(p,j);let xe=JSON.stringify(G,null,2);k.default.writeFileSync(r,xe),this.report(`Updated ${r}`)}}}loadConfig(e){return JSON.parse(k.default.readFileSync(w.default.join(e,"package.json"),"utf8"))[t.pkgJsonKey]||{}}createTraceFunction(){if(!this.logTo)return ae;if(this.logTo==="console")return e=>this.consoleTrace(e);{let e=w.default.dirname(this.logTo);return this.ensureDirExists(e),this.fileTrace(`
==== Session Started at ${new Date().toISOString()} ====`),o=>this.fileTrace(o)}}formatTrace(e){return`[${(performance.now()-this.startTime).toFixed(2)}ms] ${e}`}consoleTrace(e){console.log(this.formatTrace(e))}fileTrace(e){k.default.appendFile(this.logTo,this.formatTrace(e)+`
`,ae)}ensureDirExists(e){k.default.existsSync(e)||k.default.mkdirSync(e,{recursive:!0,mode:493})}};T.pkgJsonKey="external-workspaces";var C;function Je(t){let e=w.default.resolve(t);return(!C||C.root!==e)&&(C=new T(e)),C}});var pe=R(W=>{"use strict";Object.defineProperty(W,"__esModule",{value:!0});W.getExternalWorkspaces=void 0;var Ie=le();Object.defineProperty(W,"getExternalWorkspaces",{enumerable:!0,get:function(){return Ie.getExternalWorkspaces}})});var Qe={};Se(Qe,{default:()=>Ge});var H=l("@yarnpkg/cli"),F=l("@yarnpkg/core"),g=l("clipanion");var me=l("@yarnpkg/core"),K=b(l("fs")),ke=b(l("path"));var h=l("@yarnpkg/core");var ue=b(pe()),fe=l("@yarnpkg/core"),M=b(l("path")),x="external:";function L(){return x}var Ue=t=>t;function qe(t){return M.default.posix.normalize(t)}var Ne=process.platform==="win32"?t=>M.default.win32.normalize(t):Ue;function Be(t,e){return qe(M.default.relative(t,e))}function u(t){return(0,ue.getExternalWorkspaces)(Ne(t.cwd))}function de(t){let e=t.indexOf(":");return e===-1?t:t.slice(e+1)}function he(t){let e=t.indexOf("@",x.length+1);if(e===-1)throw new Error(`Invalid range: ${t}`);let o=t.slice(x.length,e),n=t.slice(e+1);return{name:o,version:n}}function ge(t,e){return e.startsWith(x)&&(e=e.slice(x.length)),`${x}${t}@${e}`}function J(t,e,o,n){let r={};t.workspacesByIdent.forEach(s=>{let{name:a,version:i,private:p}=s.manifest;if(a&&i&&!p){let c=fe.structUtils.stringifyIdent(a);r[c]={version:i,path:Be(t.cwd,s.cwd)}}}),e.outputWorkspaces(r,o,n)}var{makeLocator:ze,stringifyIdent:A}=h.structUtils,O=class t{constructor(){this.settings=null;this.candidates={}}static{this.protocol=L()}ensureSettings(e){this.settings||(this.settings=u(e.project))}ensureLocator(e){let o=A(e),n=de(e.range),r=this.candidates[o]??={locator:ze(e,ge(o,n)),ranges:new Set};return r.ranges.add(n),r.locator}trace(e){this.settings?.trace(e)}getResolutionDependencies(e,o){return{}}supportsDescriptor(e,o){return e.range.startsWith(t.protocol)}supportsLocator(e,o){return e.reference.startsWith(t.protocol)}shouldPersistResolution(e,o){return!0}bindDescriptor(e,o,n){return this.ensureSettings(n),e}async getCandidates(e,o,n){return this.ensureSettings(n),this.trace(`Resolver: getCandidates(${A(e)})`),[this.ensureLocator(e)]}async getSatisfying(e,o,n,r){let s=await this.getCandidates(e,o,r);return this.trace(`Resolver: getSatisfying found ${s.length} candidates`),{locators:s,sorted:!1}}async resolve(e,o){if(this.ensureSettings(o),!o.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");this.trace(`Resolving ${A(e)}`);let n=await o.fetchOptions.fetcher.fetch(e,o.fetchOptions),r=await h.miscUtils.releaseAfterUseAsync(async()=>await h.Manifest.find(n.prefixPath,{baseFs:n.packageFs}),n.releaseFs);return{...e,version:r.version||"0.0.0",languageName:r.languageName||o.project.configuration.get("defaultLanguageName"),linkType:h.LinkType.SOFT,conditions:r.getConditions(),dependencies:o.project.configuration.normalizeDependencyMap(r.dependencies),peerDependencies:r.peerDependencies,dependenciesMeta:r.dependenciesMeta,peerDependenciesMeta:r.peerDependenciesMeta,bin:r.bin}}};var ye=O.protocol,Ae=ye+"*";function Ke(t,e){let o=new Set(Object.keys(t).filter(s=>t[s].startsWith(ye))),n=new Set,r=new Set;for(let s of e)o.has(s)||n.add(s);for(let s of o)e.has(s)||r.add(s);return{addedExternals:n,removedExternals:r}}function He(t,e,o,n){let r=ke.default.join(t,"package.json"),s=JSON.parse(K.default.readFileSync(r,"utf8")),a=s.resolutions||{},{addedExternals:i,removedExternals:p}=Ke(a,e);if(i.size>0||p.size>0){n("Found changes to resolutions for external workspaces");for(let c of i)a[c]=Ae,n(`+ external workspace: ${c}`);for(let c of p)delete a[c],n(`- external workspace: ${c}`);if(!o){n(`Updating ${r} with changes to resolutions`);let c=Object.keys(a).sort().reduce((m,v)=>(m[v]=a[v],m),{});s.resolutions=c,K.default.writeFileSync(r,JSON.stringify(s,null,2))}}else n("No changes needed")}function ve(t,e){let{report:o,findPackage:n}=u(t),r=new Set,s=new Set,a=i=>{for(let p of i)for(let c of p.values())if(t.tryWorkspaceByDescriptor(c)===null){let m=me.structUtils.stringifyIdent(c);n(m)&&(r.add(m),s.has(c)||s.add(c))}};t.workspacesByIdent.forEach(i=>{a([i.manifest.dependencies,i.manifest.devDependencies])});for(let i of s){let p=t.storedResolutions.get(i.descriptorHash);if(p){let c=t.storedPackages.get(p);c&&a([c.dependencies])}}He(t.cwd,r,e,o)}var I=class extends H.BaseCommand{constructor(){super(...arguments);this.target=g.Option.String("--target","",{description:"The path to the file to output the workspaces to"});this.checkOnly=g.Option.Boolean("--check-only",!1,{description:"Check if the workspaces have changed without writing the file"});this.includePrivate=g.Option.Boolean("--include-private",!1,{description:"Include private workspaces in the output"})}static{this.paths=[["external-workspaces","output"]]}static{this.usage=g.Command.Usage({category:"External Workspaces",description:"Output current workspace information to a json file",details:`
      This command will output the current set of workspaces to a json file. The file will not be modified if the workspaces have not changed.

      The path to the .json file can optionally have a set of keys appended to the end as a path. This will write the workspaces to a subpath of
      the file while maintaining the other contents of the file.
    `,examples:[["Output workspaces with settings from package.json","$0 external-workspaces output"],["Output workspaces to target","$0 external-workspaces output --target ./path/to/file.json"],["Output workspaces to target with a subpath","$0 external-workspaces output --target ./path/to/file.json/key1/key2"],["Check if workspaces have changed","$0 external-workspaces output --target ./path/to/file.json --check-only"]]})}async execute(){let o=await F.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await F.Project.find(o,this.context.cwd),r=u(n),s=this.target||r.outputPath;s&&await J(n,r,s,this.checkOnly)}},U=class extends H.BaseCommand{constructor(){super(...arguments);this.checkOnly=g.Option.Boolean("--check-only",!1,{description:"Check if the resolutions are up to date without writing the file"})}static{this.paths=[["external-workspaces","resolutions"]]}static{this.usage=g.Command.Usage({category:"External Workspaces",description:"Check if the workspace resolutions are up to date",details:`
      This command will check the current workspace resolutions against the external dependencies defined in the package.json.
    `,examples:[["Check resolutions with settings from package.json","$0 external-workspaces resolutions"]]})}async execute(){let o=await F.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await F.Project.find(o,this.context.cwd);await ve(n,this.checkOnly)}};var V=l("@yarnpkg/core"),P=l("@yarnpkg/fslib");var q=class t{constructor(){this.settings=null;this.fetcher=null;this.resolver=null;this.resolveOptions=null}static{this.protocol=L()}ensureSettings(e){return this.settings||(this.settings=u(e.project)),this.settings}supports(e,o){return e.reference.startsWith(t.protocol)}getLocalPath(e,o){return null}async fetch(e,o){let{name:n,version:r}=he(e.reference),{findPackage:s,trace:a}=this.ensureSettings(o),i=P.npath.toPortablePath(s(n)?.path||"");return i?(a(`Fetcher: Found existing local path for ${n}: ${i}`),{packageFs:new P.CwdFS(i),prefixPath:P.PortablePath.dot,localPath:i}):await this.fetchFallback(n,r,o)}async fetchFallback(e,o,n){let r=V.structUtils.makeDescriptor(V.structUtils.parseIdent(e),o);this.resolver??=n.project.configuration.makeResolver(),this.fetcher??=n.project.configuration.makeFetcher(),this.resolveOptions??={project:n.project,resolver:this.resolver,fetchOptions:n,report:n.report};let s=await this.resolver.getCandidates(r,{},this.resolveOptions);if(s.length===0)throw new Error(`No candidate found on npm for "${e}" : "${o}"`);let a=s[0];return await this.fetcher.fetch(a,n)}};function we(t,e){let o=u(t);!o.outputOnlyOnCommand&&o.outputPath&&J(t,o)}var Ve={fetchers:[q],resolvers:[O],hooks:{afterAllInstalled:we},commands:[I,U]},Ge=Ve;return _e(Qe);})();
return plugin;
}
};
//# sourceMappingURL=external-workspaces.cjs.map
