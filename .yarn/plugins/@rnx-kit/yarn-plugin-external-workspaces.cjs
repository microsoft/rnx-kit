/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-external-workspaces",
factory: function (require) {
"use strict";var plugin=(()=>{var mt=Object.create;var T=Object.defineProperty;var kt=Object.getOwnPropertyDescriptor;var yt=Object.getOwnPropertyNames;var Pt=Object.getPrototypeOf,vt=Object.prototype.hasOwnProperty;var i=(o=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(o,{get:(t,e)=>(typeof require<"u"?require:t)[e]}):o)(function(o){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+o+'" is not supported')});var wt=(o,t)=>{for(var e in t)T(o,e,{get:t[e],enumerable:!0})},A=(o,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of yt(t))!vt.call(o,n)&&n!==e&&T(o,n,{get:()=>t[n],enumerable:!(r=kt(t,n))||r.enumerable});return o};var N=(o,t,e)=>(e=o!=null?mt(Pt(o)):{},A(t||!o||!o.__esModule?T(e,"default",{value:o,enumerable:!0}):e,o)),xt=o=>A(T({},"__esModule",{value:!0}),o);var $t={};wt($t,{default:()=>Et});var C=i("@yarnpkg/core"),y=i("@yarnpkg/fslib"),F=N(i("fs"));var V="externalWorkspacesProvider",q="externalWorkspacesOutputPath",z="externalWorkspacesOutputOnlyOnCommand",X={[V]:{description:"Relative path to a .json file of shape WorkspaceOutputJson or a .js file that exports a function of type DefinitionFinder as the default export",type:C.SettingsType.STRING,default:null},[q]:{description:"Relative path to a .json file where workspace info should be recorded. If a directory is provided the file will pick up the name from the root package.json",type:C.SettingsType.STRING,default:null},[z]:{description:"Suppress writing out the workspaces on install and only write them out when the command is invoked",type:C.SettingsType.BOOLEAN,default:!1}};function P(o){let t=y.npath.toPortablePath(o.get(V)||""),e=y.npath.toPortablePath(o.get(q)||""),r=!!o.get(z);return{provider:t,outputPath:e,outputOnlyOnCommand:r}}function Z(o){if(!F.default.existsSync(o))throw new Error(`Unable to find external workspaces definition file ${o}`);let t=JSON.parse(F.default.readFileSync(o,"utf8"))?.generated||{},{repoPath:e="",workspaces:r={}}=t,n=y.npath.toPortablePath(e);return s=>{let a=r[s];return a?{path:y.ppath.join(n,y.npath.toPortablePath(a))}:null}}function Q(o){if(!F.default.existsSync(o))throw new Error(`Unable to find external workspaces definition file ${o}`);let t=i(o).default;if(typeof t!="function")throw new Error(`External workspaces definition file ${o} does not export a function as default`);return t}var R=i("@yarnpkg/fslib");var w=i("@yarnpkg/core"),p=i("@yarnpkg/fslib"),it=N(i("fs"));var M=i("@yarnpkg/core");var Rt="external:",Lt="fallback:";function v(){return Rt}function I(){return Lt}function Y(o){let t=o.indexOf(":");return t!==-1?{protocol:o.slice(0,t+1),version:o.slice(t+1)}:{protocol:"",version:o}}function tt(o,t){let{protocol:e,version:r}=Y(o.range);return e===t?o:M.structUtils.makeDescriptor(o,`${t}${r}`)}function et(o,t){let{protocol:e,version:r}=Y(o.reference);return e===t?o:M.structUtils.makeLocator(o,`${t}${r}`)}var rt=v(),ot=I(),nt="npm:",st=[rt,ot,nt],Dt=st.map(o=>o.slice(0,-1)+"Dependency"),at=[ot,rt,nt],Ot=at.map(o=>o.slice(0,-1)+"Dependency"),W=class{constructor(t,e,r,n){this.packages=[null,null,null];this.localIndex=0;this.remoteIndex=1;this.fallbackIndex=2;this.name=t,this.localPath=r,this.isLocal=!!r,this.prettyName=e,this.trace=n,this.protocols=this.isLocal?st:at,this.dependentKeys=this.isLocal?Dt:Ot,this.isLocal||(this.localIndex=1,this.remoteIndex=0)}getResolutionDependencies(t,e){let r=this.indexFromResolverType(e)+1;return{[this.dependentKeys[r]]:this.transformDescriptor(t,r)}}async getCandidates(t,e,r,n){let s=this.indexFromResolverType(n),[a,c]=this.getNextDependencies(e,s),l=r.resolver,u=this.transformDescriptor(t,s+1),f=await l.getCandidates(u,a,r),k=f.length>0;return k&&c&&f.push(c),(s===0||f.length===0)&&this.trace(`${this.prettyName}: getCandidates: (${n}) found ${f.length} locators from ${k?"child":"package"}`),this.transformLocators(f,this.resolverLocatorIndex(n))}async getSatisfying(t,e,r,n,s){let a=this.indexFromResolverType(s),c=a+1,[l]=this.getNextDependencies(e,a),u=this.transformDescriptor(t,c),f=this.transformLocators(r,c),d=await n.resolver.getSatisfying(u,l,f,n),O=this.resolverLocatorIndex(s);return O!==c&&(d.locators=this.transformLocators(d.locators,O)),(a===0||d.locators.length===0)&&this.trace(`${this.prettyName}: getSatisfying (${s}) found ${d.locators.length} locators from ${r.length} inputs`),d}toFallbackLocator(t){return this.transformLocator(t,this.fallbackIndex)}toLeadDescriptor(t){return this.transformDescriptor(t,0)}indexFromResolverType(t){return t==="local"?this.localIndex:this.remoteIndex}resolverLocatorIndex(t){return t==="local"?this.localIndex:this.fallbackIndex}transformDescriptor(t,e){return tt(t,this.protocols[e])}transformLocator(t,e){return et(t,this.protocols[e])}transformLocators(t,e){return t.map(r=>this.transformLocator(r,e))}getNextDependencies(t,e){let r=e+1,n=t[this.dependentKeys[r]];n&&this.packages[r]===null&&(this.packages[r]=n);let s=this.packages[r],a={};return s&&(a[this.dependentKeys[r]]=s),[a,s]}};var J=o=>null,bt=p.npath.toPortablePath("package.json"),Tt=p.npath.toPortablePath(""),H=class{constructor(t){this.trace=J;this.workspaceMap=new Map;this.workspaceByIdent=new Map;this.notExternal=new Set;this.npmPackageByIdent=new Map;this.resolver=null;this.fetcher=null;this.findPackage=J;this.pathOffset=p.npath.toPortablePath("");this.trace=J,this.report=r=>console.log(r),this.root=t.cwd,this.project=t;let{provider:e}=P(t.configuration);e&&(e.endsWith(".json")?(this.pathOffset=this.findConfigPathOffset(e),this.findPackage=Z(e)):(e.endsWith(".js")||e.endsWith(".cjs"))&&(this.pathOffset=this.findConfigPathOffset(e),this.findPackage=Q(e)))}findConfigPathOffset(t){let e=p.ppath.dirname(t);return p.ppath.relative(this.root,e)}tryNameLookup(t){return this.workspaceMap.get(t)||null}createWorkspace(t,e){let r=w.structUtils.prettyIdent(this.project.configuration,w.structUtils.parseIdent(t));return new W(t,r,e,this.trace)}tryIdentLoad(t){let e=w.structUtils.stringifyIdent(t),r=this.tryNameLookup(e);if(r)return this.workspaceByIdent.set(t.identHash,r),r;let n=this.findPackage(e);if(n){let s=p.npath.toPortablePath(n.path||"");return s&&(p.ppath.isAbsolute(s)||(s=p.ppath.join(this.root,this.pathOffset,s),it.default.existsSync(p.ppath.join(s,bt))||(s=Tt))),r=this.createWorkspace(e,s),this.trace(`Loaded external workspace ${r.prettyName} of type ${n.path?"LOCAL":"REMOTE"}`),this.workspaceMap.set(e,r),this.workspaceByIdent.set(t.identHash,r),r}return this.notExternal.add(t.identHash),null}setFallbackPackage(t,e){this.npmPackageByIdent.set(t.identHash,e)}getFallbackPackage(t){return this.npmPackageByIdent.get(t.identHash)}tryByDescriptor(t){return this.workspaceByIdent.has(t.identHash)?this.workspaceByIdent.get(t.identHash):this.notExternal.has(t.identHash)||this.project.tryWorkspaceByDescriptor(t)?null:this.tryIdentLoad(t)}findByDescriptor(t){let e=this.tryByDescriptor(t);if(!e)throw new Error(`Cannot find workspace for descriptor ${w.structUtils.stringifyDescriptor(t)}`);return e}tryByLocator(t){return this.workspaceByIdent.has(t.identHash)?this.workspaceByIdent.get(t.identHash):this.notExternal.has(t.identHash)||this.project.tryWorkspaceByLocator(t)?null:this.tryIdentLoad(t)}findByLocator(t){let e=this.tryByLocator(t);if(!e)throw new Error(`Cannot find workspace for locator ${w.structUtils.stringifyLocator(t)}`);return e}getResolver(){return this.resolver??=this.project.configuration.makeResolver(),this.resolver}getFetcher(){return this.fetcher??=this.project.configuration.makeFetcher(),this.fetcher}},U=null;function x(o){return U||(U=new H(o)),U}var j=class o{constructor(){this.tracker=null}static{this.protocol=v()}ensureTracker(t){return this.tracker||(this.tracker=x(t.project)),this.tracker}supports(t,e){return t.reference.startsWith(o.protocol)}getLocalPath(t,e){let r=this.ensureTracker(e).findByLocator(t);return r.localPath?r.localPath:null}async fetch(t,e){let r=this.ensureTracker(e),n=r.findByLocator(t);if(n.localPath){let s=R.ppath.resolve(r.root,n.localPath);return{packageFs:new R.CwdFS(R.PortablePath.root),prefixPath:s,localPath:s}}return await this.fetchFallback(t,e,n)}async fetchFallback(t,e,r){let n=r.toFallbackLocator(t),a=await e.fetcher.fetch(n,e);return delete a.checksum,a}};var lt=i("@yarnpkg/fslib");var pt=i("@yarnpkg/cli"),L=i("@yarnpkg/core"),h=i("@yarnpkg/fslib"),m=i("clipanion"),g=N(i("fs"));var ct="1.0.0",E=class extends pt.BaseCommand{constructor(){super(...arguments);this.target=m.Option.String("--target","",{description:"The path to the file to output the workspaces to"});this.checkOnly=m.Option.Boolean("--check-only",!1,{description:"Check if the workspaces have changed without writing the file"});this.includePrivate=m.Option.Boolean("--include-private",!1,{description:"Include private workspaces in the output"})}static{this.paths=[["external-workspaces","output"]]}static{this.usage=m.Command.Usage({category:"External Workspaces",description:"Output current workspace information to a json file",details:`
      This command will output the current set of workspaces to a json file. The file will not be modified if the workspaces have not changed.

      The path to the .json file can optionally have a set of keys appended to the end as a path. This will write the workspaces to a subpath of
      the file while maintaining the other contents of the file.
    `,examples:[["Output workspaces with settings from package.json","$0 external-workspaces output"],["Output workspaces to target","$0 external-workspaces output --target ./path/to/file.json"],["Output workspaces to target with a subpath","$0 external-workspaces output --target ./path/to/file.json/key1/key2"],["Check if workspaces have changed","$0 external-workspaces output --target ./path/to/file.json --check-only"]]})}async execute(){let{quiet:e,stdout:r}=this.context,n=e?()=>null:u=>r.write(`${u}
`),s=await L.Configuration.find(this.context.cwd,this.context.plugins),a=P(s),{project:c}=await L.Project.find(s,this.context.cwd),l=this.target||a.outputPath;if(!l)throw new m.UsageError("No output path specified in configuration or command. Use --target to specify a path");r.write,await K(c,h.npath.toPortablePath(l),this.checkOnly,n)}};function K(o,t,e,r){let n=t.endsWith(".json"),s=n?h.ppath.dirname(t):t,a=n?h.ppath.basename(t):Wt(o.cwd);!e&&!g.default.existsSync(s)&&g.default.mkdirSync(s,{recursive:!0});let c=h.npath.join(h.npath.fromPortablePath(s),a),l={};o.workspacesByIdent.forEach(b=>{let{name:G,private:dt}=b.manifest;if(G&&!dt){let gt=L.structUtils.stringifyIdent(G);l[gt]=h.ppath.relative(o.cwd,b.cwd)}});let u=h.ppath.relative(s,o.cwd),f={repoPath:u,version:ct,workspaces:It(l)},k=g.default.existsSync(c)?JSON.parse(g.default.readFileSync(c,"utf8")):{},d=k.generated||{},O=d.repoPath||"",_=Ft(d.workspaces||{},l),ft=u!==O||d.version!==ct;if(_||ft)if(e)Ct(c,O,u,_,r);else{k.generated=f;let b=JSON.stringify(k,null,2);g.default.writeFileSync(c,b),r(`Updated workspaces in ${c}`)}}function Ct(o,t,e,r,n){if(n(`Updates needed for ${o}:`),t!==e&&n(`Repo path has changed from ${t} to ${e}`),r)for(let s in r){let a=String(r[s]).padEnd(6," ");n(`${a} - ${s}`)}}function Ft(o,t){let e={};for(let r in t)o[r]?o[r]!==t[r]&&(e[r]="update"):e[r]="add";for(let r in o)t[r]||(e[r]="remove");return Object.keys(e).length>0?e:null}function It(o){let t=Object.keys(o).sort(),e={};for(let r of t)e[r]=o[r];return e}function Wt(o){let t=h.ppath.join(o,"package.json");if(g.default.existsSync(t)){let e=JSON.parse(g.default.readFileSync(t,"utf8"));if(e.name&&typeof e.name=="string")return e.name.replace(/[^a-zA-Z0-9@._]/g,"-")+"-workspaces.json"}return"workspaces.json"}function ht(o,t){let e=P(o.configuration);if(!e.outputOnlyOnCommand&&e.outputPath){let r=n=>t.report.reportInfo(null,n);K(o,lt.npath.toPortablePath(e.outputPath),!1,r)}}async function ut(o,t,e,r,n){let a=x(t).tryByDescriptor(o);return a?a.toLeadDescriptor(o):o}var D=i("@yarnpkg/core");var $=class{constructor(t,e){this.tracker=null;this.resolverType=t,this.protocol=e}ensureTracker(t){return this.tracker||(this.tracker=x(t.project)),this.tracker}getResolutionDependencies(t,e){return this.ensureTracker(e).findByDescriptor(t).getResolutionDependencies(t,this.resolverType)}supportsDescriptor(t,e){return t.range.startsWith(this.protocol)}supportsLocator(t,e){return t.reference.startsWith(this.protocol)}shouldPersistResolution(t,e){return!1}bindDescriptor(t,e,r){return t}async getCandidates(t,e,r){return await this.ensureTracker(r).findByDescriptor(t).getCandidates(t,e,r,this.resolverType)}async getSatisfying(t,e,r,n){return await this.ensureTracker(n).findByDescriptor(t).getSatisfying(t,e,r,n,this.resolverType)}async resolve(t,e){let r=this.ensureTracker(e),n=`UNEXPECTED: resolve called for ${D.structUtils.stringifyLocator(t)} in ${this.resolverType} resolver`;throw r.trace(n),new Error(n)}},B=class o extends ${static{this.protocol=I()}constructor(){super("remote",o.protocol)}},S=class o extends ${static{this.protocol=v()}constructor(){super("local",o.protocol)}async resolve(t,e){return{...new D.Manifest,...t,version:"0.0.0",languageName:e.project.configuration.get("defaultLanguageName"),linkType:D.LinkType.SOFT}}};var jt={configuration:{...X},fetchers:[j],resolvers:[S,B],hooks:{afterAllInstalled:ht,reduceDependency:ut},commands:[E]},Et=jt;return xt($t);})();
return plugin;
}
};
//# sourceMappingURL=external-workspaces.cjs.map
