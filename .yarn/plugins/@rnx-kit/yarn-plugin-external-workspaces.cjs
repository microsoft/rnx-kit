/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-external-workspaces",
factory: function (require) {
"use strict";var plugin=(()=>{var be=Object.create;var E=Object.defineProperty;var Oe=Object.getOwnPropertyDescriptor;var Re=Object.getOwnPropertyNames;var Ee=Object.getPrototypeOf,_e=Object.prototype.hasOwnProperty;var l=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var _=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),$e=(t,e)=>{for(var r in e)E(t,r,{get:e[r],enumerable:!0})},oe=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Re(e))!_e.call(t,n)&&n!==r&&E(t,n,{get:()=>e[n],enumerable:!(o=Oe(e,n))||o.enumerable});return t};var v=(t,e,r)=>(r=t!=null?be(Ee(t)):{},oe(e||!t||!t.__esModule?E(r,"default",{value:t,enumerable:!0}):r,t)),Se=t=>oe(E({},"__esModule",{value:!0}),t);var V=_(u=>{"use strict";var Ie=u&&u.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(u,"__esModule",{value:!0});u.rebasePackageDefinition=se;u.rebaseExternalDeps=Le;u.findDependencyChanges=Ce;u.reportDependencyChanges=Be;u.sortStringRecord=Je;var ne=Ie(l("path"));function se(t,e){return{path:t.path?ne.default.posix.normalize(ne.default.join(e,t.path)):null,version:t.version}}function Le(t,e){let r={};for(let o in t)r[o]=se(t[o],e);return r}function Me(t,e){return t.path===e.path&&t.version===e.version}function Ce(t,e){let r={};for(let o in e)t[o]?Me(t[o],e[o])||(r[o]="update"):r[o]="add";for(let o in t)e[o]||(r[o]="remove");return Object.keys(r).length>0?r:null}function Be(t,e){for(let r in t){let o=String(t[r]).padEnd(6," ");e(`${o} - ${r}`)}}function Je(t,e){let r=Object.keys(t).sort();e??(e={});for(let o of r)e[o]=t[o];return e}});var de=_(d=>{"use strict";var ie=d&&d.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(d,"__esModule",{value:!0});d.parseJsonPath=le;d.getDepsFromJson=pe;d.createFinderFromJson=fe;d.createFinderFromJs=ue;d.loadExternalDeps=qe;var G=ie(l("fs")),T=ie(l("path")),Ue=V(),ae=".json",ce=t=>null;function le(t){let e=t.indexOf(ae);if(e>0){let r=e+ae.length,o=t.slice(0,r),n=t.length>r+1?t.slice(r+1):"";return{jsonPath:o,keysPath:n}}return{}}function pe(t,e){let r=e?e.split("/"):[],o=t;for(let n of r)if(o=o[n],!o)return;return o}function fe(t,e,r){if(G.default.existsSync(t)){let o=pe(JSON.parse(G.default.readFileSync(t,"utf8")),e);if(o)return r(`Loaded the finder from the json file ${t}`),n=>o[n]??null}return ce}function ue(t,e){let r=l(t);if(!r)throw new Error(`Unable to load config from ${t}`);return e(`Creating a finder from: ${t}`),r.default}function Ne(t,e,r,o){let n=new Map;return s=>{if(n.has(s))return n.get(s)??null;let a=t(s),i=a?{...a}:null;return i&&(i=(0,Ue.rebasePackageDefinition)(i,r),i.path&&(G.default.existsSync(T.default.join(e,i.path,"package.json"))?o(`finder: ${s} found at ${i.path}`):(o(`finder: ${s} not found at ${i.path}`),i.path=null))),n.set(s,i),i}}function qe(t,e,r){let o,n="";if(typeof t=="string"){if(T.default.isAbsolute(t))throw new Error(`Invalid external workspace config path: ${t}. Must be relative to the root of the repository`);let s=T.default.join(e,t);n=T.default.dirname(t);let{jsonPath:a,keysPath:i}=le(s);if(a)o=fe(a,i,r);else{let p=T.default.extname(s).toLowerCase();(p===".js"||p===".cjs")&&(o=ue(s,r))}if(!o)throw new Error(`Invalid external workspace config path: ${s}. Supported types are .json, .js, and .cjs`)}else typeof t=="object"&&(o=s=>t[s]??null);return o?Ne(o,e,n,r):ce}});var ke=_(y=>{"use strict";var ge=y&&y.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(y,"__esModule",{value:!0});y.externalWorkspacesKey=void 0;y.getExternalWorkspaces=ze;var m=ge(l("fs")),x=ge(l("path")),$=V(),Q=de(),he=()=>null;y.externalWorkspacesKey="external-workspaces";var I=class t{constructor(e){this.startTime=performance.now(),this.root=e;let{outputOnlyOnCommand:r,outputPath:o,externalDependencies:n,logTo:s}=this.loadConfig(this.root);this.outputOnlyOnCommand=!!r,this.outputPath=o||"",this.logTo=s||"",this.trace=this.createTraceFunction(),this.report=a=>{console.log(a),this.trace(a)},this.findPackage=(0,Q.loadExternalDeps)(n,e,this.trace)}outputWorkspaces(e,r,o){if(r??(r=this.outputPath),!r){this.trace("No output path specified, skipping write");return}let{jsonPath:n,keysPath:s}=(0,Q.parseJsonPath)(x.default.join(this.root,r));if(n){let a=x.default.dirname(n);o||this.ensureDirExists(a);let i=x.default.relative(a,this.root),p=(0,$.rebaseExternalDeps)(e,i),c=m.default.existsSync(n)?JSON.parse(m.default.readFileSync(n,"utf8")):{},k=(0,Q.getDepsFromJson)(c,s)||{},w=(0,$.findDependencyChanges)(k,p);if(w)if(o)this.report(`Update needed for ${r}:`),(0,$.reportDependencyChanges)(w,this.report);else{this.report(`Updating ${r}...`);let R=s?s.split("/"):[],re=R.length>0?c:{},D=re,j=R.shift();for(;j;)(!D[j]||R.length===0)&&(D[j]={}),D=D[j],j=R.shift();(0,$.sortStringRecord)(p,D);let Te=JSON.stringify(re,null,2);m.default.writeFileSync(n,Te),this.report(`Updated ${n}`)}}}loadConfig(e){return JSON.parse(m.default.readFileSync(x.default.join(e,"package.json"),"utf8"))[t.pkgJsonKey]||{}}createTraceFunction(){if(!this.logTo)return he;if(this.logTo==="console")return e=>this.consoleTrace(e);{let e=x.default.dirname(this.logTo);return this.ensureDirExists(e),this.fileTrace(`
==== Session Started at ${new Date().toISOString()} ====`),r=>this.fileTrace(r)}}formatTrace(e){return`[${(performance.now()-this.startTime).toFixed(2)}ms] ${e}`}consoleTrace(e){console.log(this.formatTrace(e))}fileTrace(e){m.default.appendFile(this.logTo,this.formatTrace(e)+`
`,he)}ensureDirExists(e){m.default.existsSync(e)||m.default.mkdirSync(e,{recursive:!0,mode:493})}};I.pkgJsonKey="external-workspaces";var S;function ze(t){let e=x.default.resolve(t);return(!S||S.root!==e)&&(S=new I(e)),S}});var X=_(L=>{"use strict";Object.defineProperty(L,"__esModule",{value:!0});L.getExternalWorkspaces=void 0;var Ae=ke();Object.defineProperty(L,"getExternalWorkspaces",{enumerable:!0,get:function(){return Ae.getExternalWorkspaces}})});var nt={};$e(nt,{default:()=>ot});var te=l("@yarnpkg/cli"),W=l("@yarnpkg/core"),g=l("clipanion");var Pe=l("@yarnpkg/core"),ee=v(l("fs")),Fe=v(l("path"));var h=l("@yarnpkg/core");var ve=v(X()),b=l("@yarnpkg/core"),q=l("@yarnpkg/fslib"),O=v(l("semver"));var me=v(X()),ye=l("@yarnpkg/core"),C=v(l("path")),M="external:";function B(){return M}var He=t=>t;function Ke(t){return C.default.posix.normalize(t)}var Ve=process.platform==="win32"?t=>C.default.win32.normalize(t):He;function Ge(t,e){return Ke(C.default.relative(t,e))}function P(t){return(0,me.getExternalWorkspaces)(Ve(t.cwd))}function we(t){let e=t.indexOf(":");return e===-1?t:t.slice(e+1)}function J(t){let e=t.indexOf(":");return e!==-1?{protocol:t.slice(0,e+1),version:t.slice(e+1)}:{protocol:"",version:t}}function U(t,e){return e.startsWith(M)&&(e=e.slice(M.length)),`${M}${e}`}function N(t,e,r,o){let n={};t.workspacesByIdent.forEach(s=>{let{name:a,version:i,private:p}=s.manifest;if(a&&i&&!p){let c=ye.structUtils.stringifyIdent(a);n[c]={version:i,path:Ge(t.cwd,s.cwd)}}}),e.outputWorkspaces(n,r,o)}var Qe={isRegularWorkspace(t,e){return e.tryWorkspaceByDescriptor(t)!==null},addIdentToWorkspace(t,e){e.descriptors.push(t)}},Xe={isRegularWorkspace(t,e){return e.tryWorkspaceByLocator(t)!==null},addIdentToWorkspace(t,e){e.locators.push(t)}},Z=class{constructor(e,r){this.workspaceMap=new Map;this.workspaceByIdent=new Map;this.notExternal=new Set;this.resolver=null;this.fetcher=null;this.findPackage=e.findPackage,this.trace=e.trace,this.report=e.report,this.root=q.npath.toPortablePath(e.root),this.project=r}tryIdentLookup(e){return this.workspaceByIdent.get(e.identHash)||null}tryNameLookup(e){return this.workspaceMap.get(e)||null}findTarget(e){return e?e.endsWith(".tgz")?"tgz":"files":"fallback"}createWorkspace(e,r){return{name:e,target:this.findTarget(r),localPath:q.npath.toPortablePath(r),descriptors:[],locators:[]}}tryIdent(e,r){let o=this.tryIdentLookup(e);if(!o&&this.notExternal.has(e.identHash))return null;if(!o){let n=b.structUtils.stringifyIdent(e);if(o=this.tryNameLookup(n),!o&&!r.isRegularWorkspace(e,this.project)){let s=this.findPackage(n);s&&(o=this.createWorkspace(n,s.path||""),this.trace(`Loaded external workspace ${n} of type ${o.target}`),this.workspaceMap.set(n,o))}o&&(r.addIdentToWorkspace(e,o),this.workspaceByIdent.set(e.identHash,o))}return o}tryByDescriptor(e){return this.tryIdent(e,Qe)}tryByLocator(e){return this.tryIdent(e,Xe)}ensureLocators(e){let r=this.tryByDescriptor(e);if(r&&!r.blockBinding){if(r.locators.length===0){let o=we(e.range),n=b.structUtils.makeLocator(e,U(r.name,o));r.locators.push(n)}return r.locators}return[]}getFallbackRange(e){let r=e.descriptors.map(s=>J(s.range).version),o=r[0],n=O.default.minVersion(o);for(let s of r){if(s==="*")return"*";if(O.default.validRange(s)){let a=O.default.minVersion(s);a&&(!n||O.default.gt(a,n))&&(n=a,o=s)}}return o}async fetchFallback(e,r){let o=b.structUtils.makeDescriptor(b.structUtils.parseIdent(e.name),this.getFallbackRange(e));this.resolver??=r.project.configuration.makeResolver(),this.fetcher??=r.project.configuration.makeFetcher();let n={project:r.project,resolver:this.resolver,fetchOptions:r,report:r.report};e.blockBinding=!0;let s=await this.resolver.getCandidates(o,{},n);if(s.length===0)throw new Error(`No candidate found on npm for "${e.name}" : "${o.range}"`);let a=s[0];return e.blockBinding=!1,this.trace(`Fetcher: falling back to generic fetch for ${e.name}: ${o.range}`),await this.fetcher.fetch(a,r)}},Y=null;function z(t){if(!Y){let e=(0,ve.getExternalWorkspaces)(q.npath.fromPortablePath(t.cwd));Y=new Z(e,t)}return Y}var{stringifyIdent:xe,makeDescriptor:Ye}=h.structUtils,F=class t{constructor(){this.tracker=null}static{this.protocol=B()}ensureTracker(e){return this.tracker||(this.tracker=z(e.project)),this.tracker}getResolutionDependencies(e,r){return{}}supportsDescriptor(e,r){let o=this.ensureTracker(r);return!!(e.range.startsWith(t.protocol)||o.tryByDescriptor(e))}supportsLocator(e,r){return e.reference.startsWith(t.protocol)}shouldPersistResolution(e,r){return!0}bindDescriptor(e,r,o){if(!e.range.startsWith(t.protocol)){let n=this.ensureTracker(o),s=n.tryByDescriptor(e);if(s&&!s.blockBinding){let{version:a}=J(e.range),i=U(xe(e),a);return n.trace(`Rebinding @${e.scope}/${e.name} to ${i}`),Ye(e,i)}}return e}async getCandidates(e,r,o){return this.ensureTracker(o).ensureLocators(e)}async getSatisfying(e,r,o,n){return{locators:await this.getCandidates(e,r,n),sorted:!1}}async resolve(e,r){let o=this.ensureTracker(r);if(!r.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");o.trace(`Resolving ${xe(e)}`);let n=await r.fetchOptions.fetcher.fetch(e,r.fetchOptions),s=await h.miscUtils.releaseAfterUseAsync(async()=>await h.Manifest.find(n.prefixPath,{baseFs:n.packageFs}),n.releaseFs);return{...e,version:s.version||"0.0.0",languageName:s.languageName||r.project.configuration.get("defaultLanguageName"),linkType:h.LinkType.SOFT,conditions:s.getConditions(),dependencies:r.project.configuration.normalizeDependencyMap(s.dependencies),peerDependencies:s.peerDependencies,dependenciesMeta:s.dependenciesMeta,peerDependenciesMeta:s.peerDependenciesMeta,bin:s.bin}}};var We=F.protocol,Ze=We+"*";function et(t,e){let r=new Set(Object.keys(t).filter(s=>t[s].startsWith(We))),o=new Set,n=new Set;for(let s of e)r.has(s)||o.add(s);for(let s of r)e.has(s)||n.add(s);return{addedExternals:o,removedExternals:n}}function tt(t,e,r,o){let n=Fe.default.join(t,"package.json"),s=JSON.parse(ee.default.readFileSync(n,"utf8")),a=s.resolutions||{},{addedExternals:i,removedExternals:p}=et(a,e);if(i.size>0||p.size>0){o("Found changes to resolutions for external workspaces");for(let c of i)a[c]=Ze,o(`+ external workspace: ${c}`);for(let c of p)delete a[c],o(`- external workspace: ${c}`);if(!r){o(`Updating ${n} with changes to resolutions`);let c=Object.keys(a).sort().reduce((k,w)=>(k[w]=a[w],k),{});s.resolutions=c,ee.default.writeFileSync(n,JSON.stringify(s,null,2))}}else o("No changes needed")}function De(t,e){let{report:r,findPackage:o}=P(t),n=new Set,s=new Set,a=i=>{for(let p of i)for(let c of p.values())if(t.tryWorkspaceByDescriptor(c)===null){let k=Pe.structUtils.stringifyIdent(c);o(k)&&(n.add(k),s.has(c)||s.add(c))}};t.workspacesByIdent.forEach(i=>{a([i.manifest.dependencies,i.manifest.devDependencies])});for(let i of s){let p=t.storedResolutions.get(i.descriptorHash);if(p){let c=t.storedPackages.get(p);c&&a([c.dependencies])}}tt(t.cwd,n,e,r)}var A=class extends te.BaseCommand{constructor(){super(...arguments);this.target=g.Option.String("--target","",{description:"The path to the file to output the workspaces to"});this.checkOnly=g.Option.Boolean("--check-only",!1,{description:"Check if the workspaces have changed without writing the file"});this.includePrivate=g.Option.Boolean("--include-private",!1,{description:"Include private workspaces in the output"})}static{this.paths=[["external-workspaces","output"]]}static{this.usage=g.Command.Usage({category:"External Workspaces",description:"Output current workspace information to a json file",details:`
      This command will output the current set of workspaces to a json file. The file will not be modified if the workspaces have not changed.

      The path to the .json file can optionally have a set of keys appended to the end as a path. This will write the workspaces to a subpath of
      the file while maintaining the other contents of the file.
    `,examples:[["Output workspaces with settings from package.json","$0 external-workspaces output"],["Output workspaces to target","$0 external-workspaces output --target ./path/to/file.json"],["Output workspaces to target with a subpath","$0 external-workspaces output --target ./path/to/file.json/key1/key2"],["Check if workspaces have changed","$0 external-workspaces output --target ./path/to/file.json --check-only"]]})}async execute(){let r=await W.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await W.Project.find(r,this.context.cwd),n=P(o),s=this.target||n.outputPath;s&&await N(o,n,s,this.checkOnly)}},H=class extends te.BaseCommand{constructor(){super(...arguments);this.checkOnly=g.Option.Boolean("--check-only",!1,{description:"Check if the resolutions are up to date without writing the file"})}static{this.paths=[["external-workspaces","resolutions"]]}static{this.usage=g.Command.Usage({category:"External Workspaces",description:"Check if the workspace resolutions are up to date",details:`
      This command will check the current workspace resolutions against the external dependencies defined in the package.json.
    `,examples:[["Check resolutions with settings from package.json","$0 external-workspaces resolutions"]]})}async execute(){let r=await W.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await W.Project.find(r,this.context.cwd);await De(o,this.checkOnly)}};var f=l("@yarnpkg/fslib");var K=class t{constructor(){this.tracker=null}static{this.protocol=B()}ensureTracker(e){return this.tracker||(this.tracker=z(e.project)),this.tracker}supports(e,r){return e.reference.startsWith(t.protocol)}getLocalPath(e,r){let o=this.ensureTracker(r).tryByLocator(e);return o&&o.localPath?o.localPath:null}async fetch(e,r){let o=this.ensureTracker(r),n=o.tryByLocator(e);if(!n)throw new Error(`Cannot find workspace for ${e.name} (${e.reference})`);if(n&&n.localPath){let s=f.ppath.resolve(o.root,n.localPath),a={packageFs:new f.CwdFS(f.PortablePath.root),prefixPath:s,localPath:s};if(n.target==="files")return o.trace(`Fetcher: Found existing local file path for ${n.name}: ${n.localPath}`),a;if(n.target==="tgz"){o.trace(`Fetcher: Linking to tarball for ${n.name}: ${n.localPath}`);let i=f.ppath.relative(f.PortablePath.dot,n.localPath);return{packageFs:new f.JailFS(f.PortablePath.root,{baseFs:a.packageFs}),releaseFs:a.releaseFs,prefixPath:i}}}return await o.fetchFallback(n,r)}};function je(t,e){let r=P(t);!r.outputOnlyOnCommand&&r.outputPath&&N(t,r)}var rt={fetchers:[K],resolvers:[F],hooks:{afterAllInstalled:je},commands:[A,H]},ot=rt;return Se(nt);})();
return plugin;
}
};
//# sourceMappingURL=external-workspaces.cjs.map
