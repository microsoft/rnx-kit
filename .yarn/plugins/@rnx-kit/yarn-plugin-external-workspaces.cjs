/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-external-workspaces",
factory: function (require) {
"use strict";var plugin=(()=>{var Ne=Object.create;var W=Object.defineProperty;var Je=Object.getOwnPropertyDescriptor;var He=Object.getOwnPropertyNames;var Ue=Object.getPrototypeOf,qe=Object.prototype.hasOwnProperty;var l=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var S=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Ke=(t,e)=>{for(var r in e)W(t,r,{get:e[r],enumerable:!0})},ne=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of He(e))!qe.call(t,s)&&s!==r&&W(t,s,{get:()=>e[s],enumerable:!(o=Je(e,s))||o.enumerable});return t};var j=(t,e,r)=>(r=t!=null?Ne(Ue(t)):{},ne(e||!t||!t.__esModule?W(r,"default",{value:t,enumerable:!0}):r,t)),ze=t=>ne(W({},"__esModule",{value:!0}),t);var Q=S(d=>{"use strict";var Ae=d&&d.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(d,"__esModule",{value:!0});d.rebasePackageDefinition=ae;d.rebaseExternalDeps=Ve;d.findDependencyChanges=Ge;d.reportDependencyChanges=Qe;d.sortStringRecord=Ye;var ie=Ae(l("path"));function ae(t,e){return{path:t.path?ie.default.posix.normalize(ie.default.join(e,t.path)):null,version:t.version}}function Ve(t,e){let r={};for(let o in t)r[o]=ae(t[o],e);return r}function Xe(t,e){return t.path===e.path&&t.version===e.version}function Ge(t,e){let r={};for(let o in e)t[o]?Xe(t[o],e[o])||(r[o]="update"):r[o]="add";for(let o in t)e[o]||(r[o]="remove");return Object.keys(r).length>0?r:null}function Qe(t,e){for(let r in t){let o=String(t[r]).padEnd(6," ");e(`${o} - ${r}`)}}function Ye(t,e){let r=Object.keys(t).sort();e??(e={});for(let o of r)e[o]=t[o];return e}});var ge=S(g=>{"use strict";var pe=g&&g.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(g,"__esModule",{value:!0});g.parseJsonPath=ue;g.getDepsFromJson=fe;g.createFinderFromJson=he;g.createFinderFromJs=de;g.loadExternalDeps=tt;var Y=pe(l("fs")),I=pe(l("path")),Ze=Q(),ce=".json",le=t=>null;function ue(t){let e=t.indexOf(ce);if(e>0){let r=e+ce.length,o=t.slice(0,r),s=t.length>r+1?t.slice(r+1):"";return{jsonPath:o,keysPath:s}}return{}}function fe(t,e){let r=e?e.split("/"):[],o=t;for(let s of r)if(o=o[s],!o)return;return o}function he(t,e,r){if(Y.default.existsSync(t)){let o=fe(JSON.parse(Y.default.readFileSync(t,"utf8")),e);if(o)return r(`Loaded the finder from the json file ${t}`),s=>o[s]??null}return le}function de(t,e){let r=l(t);if(!r)throw new Error(`Unable to load config from ${t}`);return e(`Creating a finder from: ${t}`),r.default}function et(t,e,r){let o=new Map;return s=>{if(o.has(s))return o.get(s)??null;let n=t(s),i=n?{...n}:null;return i&&(i=(0,Ze.rebasePackageDefinition)(i,r),i.path&&(Y.default.existsSync(I.default.join(e,i.path,"package.json"))||(i.path=null))),o.set(s,i),i}}function tt(t,e,r){let o,s="";if(typeof t=="string"){if(I.default.isAbsolute(t))throw new Error(`Invalid external workspace config path: ${t}. Must be relative to the root of the repository`);let n=I.default.join(e,t);s=I.default.dirname(t);let{jsonPath:i,keysPath:a}=ue(n);if(i)o=he(i,a,r);else{let p=I.default.extname(n).toLowerCase();(p===".js"||p===".cjs")&&(o=de(n,r))}if(!o)throw new Error(`Invalid external workspace config path: ${n}. Supported types are .json, .js, and .cjs`)}else typeof t=="object"&&(o=n=>t[n]??null);return o?et(o,e,s):le}});var ye=S(y=>{"use strict";var me=y&&y.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(y,"__esModule",{value:!0});y.externalWorkspacesKey=void 0;y.getExternalWorkspaces=rt;var m=me(l("fs")),x=me(l("path")),$=Q(),Z=ge(),ke=()=>null;y.externalWorkspacesKey="external-workspaces";var B=class t{constructor(e){this.startTime=performance.now(),this.root=e;let{outputOnlyOnCommand:r,outputPath:o,externalDependencies:s,logTo:n}=this.loadConfig(this.root);this.outputOnlyOnCommand=!!r,this.outputPath=o||"",this.logTo=n||"",this.trace=this.createTraceFunction(),this.report=i=>{console.log(i),this.trace(i)},this.findPackage=(0,Z.loadExternalDeps)(s,e,this.trace)}outputWorkspaces(e,r,o){if(r??(r=this.outputPath),!r){this.trace("No output path specified, skipping write");return}let{jsonPath:s,keysPath:n}=(0,Z.parseJsonPath)(x.default.join(this.root,r));if(s){let i=x.default.dirname(s);o||this.ensureDirExists(i);let a=x.default.relative(i,this.root),p=(0,$.rebaseExternalDeps)(e,a),c=m.default.existsSync(s)?JSON.parse(m.default.readFileSync(s,"utf8")):{},u=(0,Z.getDepsFromJson)(c,n)||{},f=(0,$.findDependencyChanges)(u,p);if(f)if(o)this.report(`Update needed for ${r}:`),(0,$.reportDependencyChanges)(f,this.report);else{this.report(`Updating ${r}...`);let h=n?n.split("/"):[],b=h.length>0?c:{},E=b,O=h.shift();for(;O;)(!E[O]||h.length===0)&&(E[O]={}),E=E[O],O=h.shift();(0,$.sortStringRecord)(p,E);let Me=JSON.stringify(b,null,2);m.default.writeFileSync(s,Me),this.report(`Updated ${s}`)}}}loadConfig(e){return JSON.parse(m.default.readFileSync(x.default.join(e,"package.json"),"utf8"))[t.pkgJsonKey]||{}}createTraceFunction(){if(!this.logTo)return ke;if(this.logTo==="console")return e=>this.consoleTrace(e);{let e=x.default.dirname(this.logTo);return this.ensureDirExists(e),this.fileTrace(`
==== Session Started at ${new Date().toISOString()} ====`),r=>this.fileTrace(r)}}formatTrace(e){return`[${(performance.now()-this.startTime).toFixed(2)}ms] ${e}`}consoleTrace(e){console.log(this.formatTrace(e))}fileTrace(e){m.default.appendFile(this.logTo,this.formatTrace(e)+`
`,ke)}ensureDirExists(e){m.default.existsSync(e)||m.default.mkdirSync(e,{recursive:!0,mode:493})}};B.pkgJsonKey="external-workspaces";var C;function rt(t){let e=x.default.resolve(t);return(!C||C.root!==e)&&(C=new B(e)),C}});var ee=S(M=>{"use strict";Object.defineProperty(M,"__esModule",{value:!0});M.getExternalWorkspaces=void 0;var ot=ye();Object.defineProperty(M,"getExternalWorkspaces",{enumerable:!0,get:function(){return ot.getExternalWorkspaces}})});var kt={};Ke(kt,{default:()=>gt});var se=l("@yarnpkg/cli"),T=l("@yarnpkg/core"),k=l("clipanion");var _e=l("@yarnpkg/core"),oe=j(l("fs")),We=j(l("path"));var F=l("@yarnpkg/core");var Ie=j(ee()),D=l("@yarnpkg/core"),K=l("@yarnpkg/fslib");var xe=j(ee()),N=l("@yarnpkg/core"),J=j(l("path")),ve="external:",we="fallback:",st="npm:";function v(){return ve}function H(){return we}var nt=t=>t;function it(t){return J.default.posix.normalize(t)}var at=process.platform==="win32"?t=>J.default.win32.normalize(t):nt;function ct(t,e){return it(J.default.relative(t,e))}function w(t){return(0,xe.getExternalWorkspaces)(at(t.cwd))}function De(t){let e=t.indexOf(":");return e!==-1?{protocol:t.slice(0,e+1),version:t.slice(e+1)}:{protocol:"",version:t}}function _(t,e){let{protocol:r,version:o}=De(t.range);return r===e?t:N.structUtils.makeDescriptor(t,`${e}${o}`)}function Pe(t,e){let{protocol:r,version:o}=De(t.reference);return r===e?t:N.structUtils.makeLocator(t,`${e}${o}`)}function Le(t){return _(t,ve)}function Fe(t){return _(t,st)}function Te(t){return _(t,we)}function U(t,e,r,o){let s={};t.workspacesByIdent.forEach(n=>{let{name:i,version:a,private:p}=n.manifest;if(i&&a&&!p){let c=N.structUtils.stringifyIdent(i);s[c]={version:a,path:ct(t.cwd,n.cwd)}}}),e.outputWorkspaces(s,r,o)}var Re=v(),be=H(),Ee="npm:",Oe=[Re,be,Ee],pt=Oe.map(t=>t.slice(0,-1)+"Dependency"),je=[be,Re,Ee],lt=je.map(t=>t.slice(0,-1)+"Dependency"),q=class{constructor(e,r,o,s){this.packages=[null,null,null];this.localIndex=0;this.remoteIndex=1;this.fallbackIndex=2;this.name=e,this.localPath=o,this.isLocal=!!o,this.prettyName=r,this.trace=s,this.protocols=this.isLocal?Oe:je,this.dependentKeys=this.isLocal?pt:lt,this.isLocal||(this.localIndex=1,this.remoteIndex=0)}getResolutionDependencies(e,r){let o=this.indexFromResolverType(r)+1;return{[this.dependentKeys[o]]:this.transformDescriptor(e,o)}}async getCandidates(e,r,o,s){let n=this.indexFromResolverType(s),[i,a]=this.getNextDependencies(r,n),p=o.resolver,c=this.transformDescriptor(e,n+1),u=await p.getCandidates(c,i,o),f=u.length>0;return f&&a&&u.push(a),(n===0||u.length===0)&&this.trace(`${this.prettyName}: getCandidates: (${s}) found ${u.length} locators from ${f?"child":"package"}`),this.transformLocators(u,this.resolverLocatorIndex(s))}async getSatisfying(e,r,o,s,n){let i=this.indexFromResolverType(n),a=i+1,[p]=this.getNextDependencies(r,i),c=this.transformDescriptor(e,a),u=this.transformLocators(o,a),h=await s.resolver.getSatisfying(c,p,u,s),b=this.resolverLocatorIndex(n);return b!==a&&(h.locators=this.transformLocators(h.locators,b)),(i===0||h.locators.length===0)&&this.trace(`${this.prettyName}: getSatisfying (${n}) found ${h.locators.length} locators from ${o.length} inputs`),h}toFallbackLocator(e){return this.transformLocator(e,this.fallbackIndex)}indexFromResolverType(e){return e==="local"?this.localIndex:this.remoteIndex}resolverLocatorIndex(e){return e==="local"?this.localIndex:this.fallbackIndex}transformDescriptor(e,r){return _(e,this.protocols[r])}transformLocator(e,r){return Pe(e,this.protocols[r])}transformLocators(e,r){return e.map(o=>this.transformLocator(o,r))}getNextDependencies(e,r){let o=r+1,s=e[this.dependentKeys[o]];s&&this.packages[o]===null&&(this.packages[o]=s);let n=this.packages[o],i={};return n&&(i[this.dependentKeys[o]]=n),[i,n]}};var re=class{constructor(e,r){this.workspaceMap=new Map;this.workspaceByIdent=new Map;this.notExternal=new Set;this.npmPackageByIdent=new Map;this.resolver=null;this.fetcher=null;this.findPackage=e.findPackage,this.trace=e.trace,this.report=e.report,this.root=K.npath.toPortablePath(e.root),this.project=r}tryNameLookup(e){return this.workspaceMap.get(e)||null}createWorkspace(e,r){let o=D.structUtils.prettyIdent(this.project.configuration,D.structUtils.parseIdent(e));return new q(e,o,K.npath.toPortablePath(r),this.trace)}tryIdentLoad(e){let r=D.structUtils.stringifyIdent(e),o=this.tryNameLookup(r);if(o)return this.workspaceByIdent.set(e.identHash,o),o;let s=this.findPackage(r);return s?(o=this.createWorkspace(r,s.path||""),this.trace(`Loaded external workspace ${o.prettyName} of type ${s.path?"LOCAL":"REMOTE"}`),this.workspaceMap.set(r,o),this.workspaceByIdent.set(e.identHash,o),o):(this.notExternal.add(e.identHash),null)}setFallbackPackage(e,r){this.npmPackageByIdent.set(e.identHash,r)}getFallbackPackage(e){return this.npmPackageByIdent.get(e.identHash)}tryByDescriptor(e){return this.workspaceByIdent.has(e.identHash)?this.workspaceByIdent.get(e.identHash):this.notExternal.has(e.identHash)||this.project.tryWorkspaceByDescriptor(e)?null:this.tryIdentLoad(e)}findByDescriptor(e){let r=this.tryByDescriptor(e);if(!r)throw new Error(`Cannot find workspace for descriptor ${D.structUtils.stringifyDescriptor(e)}`);return r}tryByLocator(e){return this.workspaceByIdent.has(e.identHash)?this.workspaceByIdent.get(e.identHash):this.notExternal.has(e.identHash)||this.project.tryWorkspaceByLocator(e)?null:this.tryIdentLoad(e)}findByLocator(e){let r=this.tryByLocator(e);if(!r)throw new Error(`Cannot find workspace for locator ${D.structUtils.stringifyLocator(e)}`);return r}getResolver(){return this.resolver??=this.project.configuration.makeResolver(),this.resolver}getFetcher(){return this.fetcher??=this.project.configuration.makeFetcher(),this.fetcher}getNpmDescriptor(e){return Fe(e)}},te=null;function P(t){if(!te){let e=(0,Ie.getExternalWorkspaces)(K.npath.fromPortablePath(t.cwd));te=new re(e,t)}return te}var z=class{constructor(e,r){this.tracker=null;this.resolverType=e,this.protocol=r}ensureTracker(e){return this.tracker||(this.tracker=P(e.project)),this.tracker}getResolutionDependencies(e,r){return this.ensureTracker(r).findByDescriptor(e).getResolutionDependencies(e,this.resolverType)}supportsDescriptor(e,r){return e.range.startsWith(this.protocol)}supportsLocator(e,r){return e.reference.startsWith(this.protocol)}shouldPersistResolution(e,r){return!1}bindDescriptor(e,r,o){return e}async getCandidates(e,r,o){return await this.ensureTracker(o).findByDescriptor(e).getCandidates(e,r,o,this.resolverType)}async getSatisfying(e,r,o,s){return await this.ensureTracker(s).findByDescriptor(e).getSatisfying(e,r,o,s,this.resolverType)}async resolve(e,r){let o=this.ensureTracker(r),s=`UNEXPECTED: resolve called for ${F.structUtils.stringifyLocator(e)} in ${this.resolverType} resolver`;throw o.trace(s),new Error(s)}},A=class t extends z{static{this.protocol=H()}constructor(){super("remote",t.protocol)}},L=class t extends z{static{this.protocol=v()}constructor(){super("local",t.protocol)}async resolve(e,r){return{...new F.Manifest,...e,version:"0.0.0",languageName:r.project.configuration.get("defaultLanguageName"),linkType:F.LinkType.SOFT}}};var Se=L.protocol,ut=Se+"*";function ft(t,e){let r=new Set(Object.keys(t).filter(n=>t[n].startsWith(Se))),o=new Set,s=new Set;for(let n of e)r.has(n)||o.add(n);for(let n of r)e.has(n)||s.add(n);return{addedExternals:o,removedExternals:s}}function ht(t,e,r,o){let s=We.default.join(t,"package.json"),n=JSON.parse(oe.default.readFileSync(s,"utf8")),i=n.resolutions||{},{addedExternals:a,removedExternals:p}=ft(i,e);if(a.size>0||p.size>0){o("Found changes to resolutions for external workspaces");for(let c of a)i[c]=ut,o(`+ external workspace: ${c}`);for(let c of p)delete i[c],o(`- external workspace: ${c}`);if(!r){o(`Updating ${s} with changes to resolutions`);let c=Object.keys(i).sort().reduce((u,f)=>(u[f]=i[f],u),{});n.resolutions=c,oe.default.writeFileSync(s,JSON.stringify(n,null,2))}}else o("No changes needed")}function $e(t,e){let{report:r,findPackage:o}=w(t),s=new Set,n=new Set,i=a=>{for(let p of a)for(let c of p.values())if(t.tryWorkspaceByDescriptor(c)===null){let u=_e.structUtils.stringifyIdent(c);o(u)&&(s.add(u),n.has(c)||n.add(c))}};t.workspacesByIdent.forEach(a=>{i([a.manifest.dependencies,a.manifest.devDependencies])});for(let a of n){let p=t.storedResolutions.get(a.descriptorHash);if(p){let c=t.storedPackages.get(p);c&&i([c.dependencies])}}ht(t.cwd,s,e,r)}var V=class extends se.BaseCommand{constructor(){super(...arguments);this.target=k.Option.String("--target","",{description:"The path to the file to output the workspaces to"});this.checkOnly=k.Option.Boolean("--check-only",!1,{description:"Check if the workspaces have changed without writing the file"});this.includePrivate=k.Option.Boolean("--include-private",!1,{description:"Include private workspaces in the output"})}static{this.paths=[["external-workspaces","output"]]}static{this.usage=k.Command.Usage({category:"External Workspaces",description:"Output current workspace information to a json file",details:`
      This command will output the current set of workspaces to a json file. The file will not be modified if the workspaces have not changed.

      The path to the .json file can optionally have a set of keys appended to the end as a path. This will write the workspaces to a subpath of
      the file while maintaining the other contents of the file.
    `,examples:[["Output workspaces with settings from package.json","$0 external-workspaces output"],["Output workspaces to target","$0 external-workspaces output --target ./path/to/file.json"],["Output workspaces to target with a subpath","$0 external-workspaces output --target ./path/to/file.json/key1/key2"],["Check if workspaces have changed","$0 external-workspaces output --target ./path/to/file.json --check-only"]]})}async execute(){let r=await T.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await T.Project.find(r,this.context.cwd),s=w(o),n=this.target||s.outputPath;n&&await U(o,s,n,this.checkOnly)}},X=class extends se.BaseCommand{constructor(){super(...arguments);this.checkOnly=k.Option.Boolean("--check-only",!1,{description:"Check if the resolutions are up to date without writing the file"})}static{this.paths=[["external-workspaces","resolutions"]]}static{this.usage=k.Command.Usage({category:"External Workspaces",description:"Check if the workspace resolutions are up to date",details:`
      This command will check the current workspace resolutions against the external dependencies defined in the package.json.
    `,examples:[["Check resolutions with settings from package.json","$0 external-workspaces resolutions"]]})}async execute(){let r=await T.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await T.Project.find(r,this.context.cwd);await $e(o,this.checkOnly)}};var R=l("@yarnpkg/fslib");var G=class t{constructor(){this.tracker=null}static{this.protocol=v()}ensureTracker(e){return this.tracker||(this.tracker=P(e.project)),this.tracker}supports(e,r){return e.reference.startsWith(t.protocol)}getLocalPath(e,r){let o=this.ensureTracker(r).findByLocator(e);return o.localPath?o.localPath:null}async fetch(e,r){let o=this.ensureTracker(r),s=o.findByLocator(e),n=await this.fetchFallback(e,r,s);if(s.localPath){let i=R.ppath.resolve(o.root,s.localPath),{checksum:a}=n;return a||o.trace(`Fetcher: failed to find checksum for ${s.prettyName}`),{packageFs:new R.CwdFS(R.PortablePath.root),prefixPath:i,localPath:i,checksum:a}}return n}async fetchFallback(e,r,o){let s=o.toFallbackLocator(e);return await r.fetcher.fetch(s,r)}};function Ce(t,e){let r=w(t);!r.outputOnlyOnCommand&&r.outputPath&&U(t,r)}async function Be(t,e,r,o,s){let n=P(e),i=n.tryByDescriptor(t);return i?i.localPath?(n.trace(`Reducing ${i.name} to external descriptor`),Le(t)):(n.trace(`Reducing ${i.name} to fallback descriptor`),Te(t)):t}var dt={fetchers:[G],resolvers:[L,A],hooks:{afterAllInstalled:Ce,reduceDependency:Be},commands:[V,X]},gt=dt;return ze(kt);})();
return plugin;
}
};
//# sourceMappingURL=external-workspaces.cjs.map
