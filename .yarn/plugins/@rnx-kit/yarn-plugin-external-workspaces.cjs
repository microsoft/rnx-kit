/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-external-workspaces",
factory: function (require) {
"use strict";var plugin=(()=>{var ye=Object.create;var j=Object.defineProperty;var ve=Object.getOwnPropertyDescriptor;var xe=Object.getOwnPropertyNames;var Oe=Object.getPrototypeOf,Ee=Object.prototype.hasOwnProperty;var l=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var S=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),_e=(e,t)=>{for(var n in t)j(e,n,{get:t[n],enumerable:!0})},L=(e,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of xe(t))!Ee.call(e,r)&&r!==n&&j(e,r,{get:()=>t[r],enumerable:!(o=ve(t,r))||o.enumerable});return e};var k=(e,t,n)=>(n=e!=null?ye(Oe(e)):{},L(t||!e||!e.__esModule?j(n,"default",{value:e,enumerable:!0}):n,e)),De=e=>L(j({},"__esModule",{value:!0}),e);var F=S(d=>{"use strict";var q=d&&d.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(d,"__esModule",{value:!0});d.parseJsonPath=B;d.getDepsFromJson=A;d.createFinderFromJson=H;d.createFinderFromJs=X;d.loadExternalDeps=Se;var C=q(l("fs")),y=q(l("path")),U=".json",N=e=>null;function B(e){let t=e.indexOf(U);if(t>0){let n=t+U.length,o=e.slice(0,n),r=e.length>n+1?e.slice(n+1):"";return{jsonPath:o,keysPath:r}}return{}}function A(e,t){let n=t?t.split("/"):[],o=e;for(let r of n)if(o=o[r],!o)return;return o}function H(e,t,n){if(C.default.existsSync(e)){let o=A(JSON.parse(C.default.readFileSync(e,"utf8")),t);if(o)return n(`Loaded the finder from the json file ${e}`,!0),r=>o[r]??null}return N}function X(e,t){let n=l(e);if(!n)throw new Error(`Unable to load config from ${e}`);return t(`Creating a finder from: ${e}`,!0),n.default}function je(e,t,n){let o=new Map;return r=>{if(o.has(r))return o.get(r)??null;let s=e(r),i=s?{...s}:null;return i&&i.path&&(y.default.isAbsolute(i.path)||(i.path=y.default.resolve(t,i.path)),C.default.existsSync(y.default.join(i.path,"package.json"))?n(`finder: ${r} found at ${i.path}`,!0):(n(`finder: ${r} not found at ${i.path}`,!0),i.path=void 0)),o.set(r,i),i}}function Se(e,t,n){let o;if(typeof e=="string"){let r=y.default.resolve(t,e),{jsonPath:s,keysPath:i}=B(r);if(t=y.default.dirname(s||r),s)o=H(s,i,n);else{let a=y.default.extname(r).toLowerCase();(a===".js"||a===".cjs")&&(o=X(r,n))}if(!o)throw new Error(`Invalid external workspace config path: ${r}. Supported types are .json, .js, and .cjs`)}else typeof e=="object"&&(o=r=>e[r]??null);return o?je(o,t,n):N}});var G=S(D=>{"use strict";var V=D&&D.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(D,"__esModule",{value:!0});D.writeOutWorkspaces=$e;var T=V(l("fs")),J=V(l("path")),K=F();function z(e,t){let n=Object.entries(e).map(([o,r])=>({name:o,...r}));return t?n.sort((o,r)=>o.name.localeCompare(r.name)):n}function Fe(e,t){for(let{name:n,...o}of e)t[n]=o}function Pe(e,t){return e.length===t.length&&e.every((n,o)=>n.name===t[o].name&&n.path===t[o].path&&n.version===t[o].version)}function $e(e,t,n,o){let{jsonPath:r,keysPath:s}=(0,K.parseJsonPath)(t);if(!r)throw new Error(`Invalid output path: ${t}`);let i=J.default.dirname(J.default.resolve(r)),a=z(e,!0);for(let R of a)R.path&&(R.path=J.default.relative(i,R.path));let u=T.default.existsSync(r)?JSON.parse(T.default.readFileSync(r,"utf8")):{},c=(0,K.getDepsFromJson)(u,s);if(c&&Pe(a,z(c))){o(`No changes to ${r}, skipping update`,!0);return}if(n){o(`Changes detected in ${r}, skipping write`);return}let p=s?s.split("/"):[],w=p.length>0?u:{},E=w,_=p.shift();for(;_;)(!E[_]||p.length===0)&&(E[_]={}),E=E[_],_=p.shift();Fe(a,E);let we=JSON.stringify(w,null,2);T.default.writeFileSync(r,we),o(`Updated ${r}`)}});var ne=S(h=>{"use strict";var Y=h&&h.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(h,"__esModule",{value:!0});h.externalWorkspacesKey=void 0;h.settingsFromConfig=te;h.getExternalWorkspacesSettings=Re;var P=Y(l("fs")),Z=Y(l("path")),be=F();h.externalWorkspacesKey="external-workspaces";var ee=()=>null;function Q(e,t){P.default.appendFile(t,e,ee)}function We(e){if(typeof e=="string"){let t=performance.now();if(e==="console")return(n,o)=>{o||console.log(n)};{let n=Z.default.dirname(e);return n&&!P.default.existsSync(n)&&P.default.mkdirSync(n,{recursive:!0,mode:493}),Q(`
==== Session Started at ${new Date().toISOString()} ====
`,e),o=>{Q(`[${(performance.now()-t).toFixed(2)}ms] ${o}
`,e)}}}return ee}function te(e,t){let{logTo:n,externalDependencies:o,...r}=t,s=We(t.logTo);return{finder:(0,be.loadExternalDeps)(o,e,s),trace:s,...r}}function Re(e,t){let o=JSON.parse(P.default.readFileSync(Z.default.join(e,"package.json"),"utf8"))[h.externalWorkspacesKey]||{};return t&&!o.logTo&&(o.logTo="console"),te(e,o)}});var v=S(f=>{"use strict";Object.defineProperty(f,"__esModule",{value:!0});f.settingsFromConfig=f.getExternalWorkspacesSettings=f.writeOutWorkspaces=f.loadExternalDeps=void 0;var Ce=F();Object.defineProperty(f,"loadExternalDeps",{enumerable:!0,get:function(){return Ce.loadExternalDeps}});var Te=G();Object.defineProperty(f,"writeOutWorkspaces",{enumerable:!0,get:function(){return Te.writeOutWorkspaces}});var oe=ne();Object.defineProperty(f,"getExternalWorkspacesSettings",{enumerable:!0,get:function(){return oe.getExternalWorkspacesSettings}});Object.defineProperty(f,"settingsFromConfig",{enumerable:!0,get:function(){return oe.settingsFromConfig}})});var Ne={};_e(Ne,{default:()=>qe});var ge=k(v()),I=l("@yarnpkg/cli"),O=l("@yarnpkg/core"),m=l("clipanion");var re=k(v()),se=l("@yarnpkg/core");function $(e,t,n,o,r){if(t.indexOf(".json")===-1)r(`Invalid output path: ${t}, must reference a .json file`);else{let s={};e.workspacesByIdent.forEach(i=>{let{name:a,version:u,private:c}=i.manifest;if(a&&u&&(!c||n)){let p=se.structUtils.stringifyIdent(a);s[p]={version:u,path:i.cwd}}}),(0,re.writeOutWorkspaces)(s,t,o,r)}}var ue=k(v()),pe=l("@yarnpkg/core"),M=k(l("fs")),fe=k(l("path"));var ce=k(v()),le=l("@yarnpkg/core"),{makeDescriptor:ie,makeLocator:Je,stringifyIdent:g}=le.structUtils,ae=()=>null,x=class e{constructor(){this.finder=ae;this.trace=ae;this.settingsLoaded=!1;this.report=void 0}static{this.protocol="external:"}ensureSettings(t){if(!this.settingsLoaded){let n=(0,ce.getExternalWorkspacesSettings)(t.project.cwd);this.finder=n.finder,this.trace=n.trace,this.settingsLoaded=!0}}getResolutionDependencies(t,n){return this.trace(`UNEXPECTED: getResolutionDependencies called for ${g(t)}`,!0),{}}supportsDescriptor(t,n){this.ensureSettings(n);let o=t.range.startsWith(e.protocol);return this.trace(`supportsDescriptor called for ${g(t)} : ${t.range}`,!0),o}supportsLocator(t,n){let o=t.reference.startsWith(e.protocol);return this.trace(`UNEXPECTED: supportsLocator called for ${g(t)}`,!0),o}shouldPersistResolution(t,n){return!1}bindDescriptor(t,n,o){this.ensureSettings(o);let r=g(t),s=this.finder(r);if(!s)throw Error(`Unknown external workspace "${r}:${e.protocol}" included by "${g(n)}"`);return s.path?(this.trace(`bindDescriptor transforming ${r} to "portal:${s.path}"`,!0),ie(t,`portal:${s.path}`)):(this.trace(`bindDescriptor transforming ${r} to "npm:${s.version}"`,!0),ie(t,`npm:${s.version}`))}async getCandidates(t,n,o){return this.trace(`UNEXPECTED: getCandidates called for ${g(t)}`,!0),[Je(t,t.range)]}async getSatisfying(t,n,o,r){this.report??=r.report,this.trace(`UNEXPECTEDP: getSatisfying called for ${g(t)}`,!0);let[s]=await this.getCandidates(t,n,r);return{locators:o.filter(i=>i.locatorHash===s.locatorHash),sorted:!1}}async resolve(t,n){return this.report??=n.report,this.trace(`UNEXPECTED: Resolving external locator ${g(t)}`,!0),{...t,name:t.name,version:"0.0.0",languageName:"unknown",conditions:null}}};var de=x.protocol,Me=de+"*";function Ie(e,t){let n=new Set(Object.keys(e).filter(s=>e[s].startsWith(de))),o=new Set,r=new Set;for(let s of t)n.has(s)||o.add(s);for(let s of n)t.has(s)||r.add(s);return{addedExternals:o,removedExternals:r}}function Le(e,t,n,o){let r=fe.default.join(e,"package.json"),s=JSON.parse(M.default.readFileSync(r,"utf8")),i=s.resolutions||{},{addedExternals:a,removedExternals:u}=Ie(i,t);if(a.size>0||u.size>0){o("Found changes to resolutions for external workspaces");for(let c of a)i[c]=Me,o(`+ external workspace: ${c}`);for(let c of u)delete i[c],o(`- external workspace: ${c}`);if(!n){o(`Updating ${r} with changes to resolutions`);let c=Object.keys(i).sort().reduce((p,w)=>(p[w]=i[w],p),{});s.resolutions=c,M.default.writeFileSync(r,JSON.stringify(s,null,2))}}else o("No changes needed")}function he(e,t){let{trace:n,finder:o}=(0,ue.getExternalWorkspacesSettings)(e.cwd,!0),r=new Set,s=new Set,i=a=>{for(let u of a)for(let c of u.values())if(e.tryWorkspaceByDescriptor(c)===null){let p=pe.structUtils.stringifyIdent(c);o(p)&&(r.add(p),s.has(c)||s.add(c))}};e.workspacesByIdent.forEach(a=>{i([a.manifest.dependencies,a.manifest.devDependencies])});for(let a of s){let u=e.storedResolutions.get(a.descriptorHash);if(u){let c=e.storedPackages.get(u);c&&i([c.dependencies])}}Le(e.cwd,r,t,n)}var b=class extends I.BaseCommand{constructor(){super(...arguments);this.target=m.Option.String("--target","",{description:"The path to the file to output the workspaces to"});this.checkOnly=m.Option.Boolean("--check-only",!1,{description:"Check if the workspaces have changed without writing the file"});this.includePrivate=m.Option.Boolean("--include-private",!1,{description:"Include private workspaces in the output"})}static{this.paths=[["external-workspaces","output"]]}static{this.usage=m.Command.Usage({category:"External Workspaces",description:"Output current workspace information to a json file",details:`
      This command will output the current set of workspaces to a json file. The file will not be modified if the workspaces have not changed.

      The path to the .json file can optionally have a set of keys appended to the end as a path. This will write the workspaces to a subpath of
      the file while maintaining the other contents of the file.
    `,examples:[["Output workspaces with settings from package.json","$0 external-workspaces output"],["Output workspaces to target","$0 external-workspaces output --target ./path/to/file.json"],["Output workspaces to target with a subpath","$0 external-workspaces output --target ./path/to/file.json/key1/key2"],["Check if workspaces have changed","$0 external-workspaces output --target ./path/to/file.json --check-only"]]})}async execute(){let n=await O.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await O.Project.find(n,this.context.cwd),r=(0,ge.getExternalWorkspacesSettings)(o.cwd,!0),s=this.target||r.outputPath,i=this.includePrivate||r.outputPrivateWorkspaces,a=r.trace;s&&await $(o,s,i,this.checkOnly,a)}},W=class extends I.BaseCommand{constructor(){super(...arguments);this.checkOnly=m.Option.Boolean("--check-only",!1,{description:"Check if the resolutions are up to date without writing the file"})}static{this.paths=[["external-workspaces","resolutions"]]}static{this.usage=m.Command.Usage({category:"External Workspaces",description:"Check if the workspace resolutions are up to date",details:`
      This command will check the current workspace resolutions against the external dependencies defined in the package.json.
    `,examples:[["Check resolutions with settings from package.json","$0 external-workspaces resolutions"]]})}async execute(){let n=await O.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await O.Project.find(n,this.context.cwd);await he(o,this.checkOnly)}};var me=k(v());function ke(e,t){let{outputPath:n,outputOnlyOnCommand:o,outputPrivateWorkspaces:r,trace:s}=(0,me.getExternalWorkspacesSettings)(e.cwd,!0);!o&&n&&$(e,n,r,!1,s)}var Ue={resolvers:[x],hooks:{afterAllInstalled:ke},commands:[b,W]},qe=Ue;return De(Ne);})();
return plugin;
}
};
//# sourceMappingURL=external-workspaces.cjs.map
