/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-external-workspaces",
factory: function (require) {
"use strict";var plugin=(()=>{var ve=Object.create;var _=Object.defineProperty;var Pe=Object.getOwnPropertyDescriptor;var Oe=Object.getOwnPropertyNames;var je=Object.getPrototypeOf,Ee=Object.prototype.hasOwnProperty;var l=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,o)=>(typeof require<"u"?require:e)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var R=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Fe=(t,e)=>{for(var o in e)_(t,o,{get:e[o],enumerable:!0})},V=(t,e,o,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Oe(e))!Ee.call(t,r)&&r!==o&&_(t,r,{get:()=>e[r],enumerable:!(n=Pe(e,r))||n.enumerable});return t};var $=(t,e,o)=>(o=t!=null?ve(je(t)):{},V(e||!t||!t.__esModule?_(o,"default",{value:t,enumerable:!0}):o,t)),De=t=>V(_({},"__esModule",{value:!0}),t);var N=R(f=>{"use strict";var Se=f&&f.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(f,"__esModule",{value:!0});f.rebasePackageDefinition=Q;f.rebaseExternalDeps=_e;f.findDependencyChanges=$e;f.reportDependencyChanges=be;f.sortStringRecord=Ce;var G=Se(l("path"));function Q(t,e){return{path:t.path?G.default.posix.normalize(G.default.join(e,t.path)):null,version:t.version}}function _e(t,e){let o={};for(let n in t)o[n]=Q(t[n],e);return o}function Re(t,e){return t.path===e.path&&t.version===e.version}function $e(t,e){let o={};for(let n in e)t[n]?Re(t[n],e[n])||(o[n]="update"):o[n]="add";for(let n in t)e[n]||(o[n]="remove");return Object.keys(o).length>0?o:null}function be(t,e){for(let o in t){let n=String(t[o]).padEnd(6," ");e(`${n} - ${o}`)}}function Ce(t,e){let o=Object.keys(t).sort();e??(e={});for(let n of o)e[n]=t[n];return e}});var se=R(d=>{"use strict";var Z=d&&d.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(d,"__esModule",{value:!0});d.parseJsonPath=te;d.getDepsFromJson=oe;d.createFinderFromJson=ne;d.createFinderFromJs=re;d.loadExternalDeps=Je;var B=Z(l("fs")),F=Z(l("path")),Te=N(),Y=".json",ee=t=>null;function te(t){let e=t.indexOf(Y);if(e>0){let o=e+Y.length,n=t.slice(0,o),r=t.length>o+1?t.slice(o+1):"";return{jsonPath:n,keysPath:r}}return{}}function oe(t,e){let o=e?e.split("/"):[],n=t;for(let r of o)if(n=n[r],!n)return;return n}function ne(t,e,o){if(B.default.existsSync(t)){let n=oe(JSON.parse(B.default.readFileSync(t,"utf8")),e);if(n)return o(`Loaded the finder from the json file ${t}`),r=>n[r]??null}return ee}function re(t,e){let o=l(t);if(!o)throw new Error(`Unable to load config from ${t}`);return e(`Creating a finder from: ${t}`),o.default}function We(t,e,o,n){let r=new Map;return s=>{if(r.has(s))return r.get(s)??null;let a=t(s),i=a?{...a}:null;return i&&(i=(0,Te.rebasePackageDefinition)(i,o),i.path&&(B.default.existsSync(F.default.join(e,i.path,"package.json"))?n(`finder: ${s} found at ${i.path}`):(n(`finder: ${s} not found at ${i.path}`),i.path=null))),r.set(s,i),i}}function Je(t,e,o){let n,r="";if(typeof t=="string"){if(F.default.isAbsolute(t))throw new Error(`Invalid external workspace config path: ${t}. Must be relative to the root of the repository`);let s=F.default.join(e,t);r=F.default.dirname(t);let{jsonPath:a,keysPath:i}=te(s);if(a)n=ne(a,i,o);else{let p=F.default.extname(s).toLowerCase();(p===".js"||p===".cjs")&&(n=re(s,o))}if(!n)throw new Error(`Invalid external workspace config path: ${s}. Supported types are .json, .js, and .cjs`)}else typeof t=="object"&&(n=s=>t[s]??null);return n?We(n,e,r,o):ee}});var ce=R(k=>{"use strict";var ae=k&&k.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(k,"__esModule",{value:!0});k.externalWorkspacesKey=void 0;k.getExternalWorkspaces=Me;var m=ae(l("fs")),w=ae(l("path")),b=N(),z=se(),ie=()=>null;k.externalWorkspacesKey="external-workspaces";var T=class t{constructor(e){this.startTime=performance.now(),this.root=e;let{outputOnlyOnCommand:o,outputPath:n,externalDependencies:r,logTo:s}=this.loadConfig(this.root);this.outputOnlyOnCommand=!!o,this.outputPath=n||"",this.logTo=s||"",this.trace=this.createTraceFunction(),this.report=a=>{console.log(a),this.trace(a)},this.findPackage=(0,z.loadExternalDeps)(r,e,this.trace)}outputWorkspaces(e,o,n){if(o??(o=this.outputPath),!o){this.trace("No output path specified, skipping write");return}let{jsonPath:r,keysPath:s}=(0,z.parseJsonPath)(w.default.join(this.root,o));if(r){let a=w.default.dirname(r);n||this.ensureDirExists(a);let i=w.default.relative(a,this.root),p=(0,b.rebaseExternalDeps)(e,i),c=m.default.existsSync(r)?JSON.parse(m.default.readFileSync(r,"utf8")):{},g=(0,z.getDepsFromJson)(c,s)||{},y=(0,b.findDependencyChanges)(g,p);if(y)if(n)this.report(`Update needed for ${o}:`),(0,b.reportDependencyChanges)(y,this.report);else{this.report(`Updating ${o}...`);let S=s?s.split("/"):[],X=S.length>0?c:{},j=X,E=S.shift();for(;E;)(!j[E]||S.length===0)&&(j[E]={}),j=j[E],E=S.shift();(0,b.sortStringRecord)(p,j);let xe=JSON.stringify(X,null,2);m.default.writeFileSync(r,xe),this.report(`Updated ${r}`)}}}loadConfig(e){return JSON.parse(m.default.readFileSync(w.default.join(e,"package.json"),"utf8"))[t.pkgJsonKey]||{}}createTraceFunction(){if(!this.logTo)return ie;if(this.logTo==="console")return e=>this.consoleTrace(e);{let e=w.default.dirname(this.logTo);return this.ensureDirExists(e),this.fileTrace(`
==== Session Started at ${new Date().toISOString()} ====`),o=>this.fileTrace(o)}}formatTrace(e){return`[${(performance.now()-this.startTime).toFixed(2)}ms] ${e}`}consoleTrace(e){console.log(this.formatTrace(e))}fileTrace(e){m.default.appendFile(this.logTo,this.formatTrace(e)+`
`,ie)}ensureDirExists(e){m.default.existsSync(e)||m.default.mkdirSync(e,{recursive:!0,mode:493})}};T.pkgJsonKey="external-workspaces";var C;function Me(t){let e=w.default.resolve(t);return(!C||C.root!==e)&&(C=new T(e)),C}});var le=R(W=>{"use strict";Object.defineProperty(W,"__esModule",{value:!0});W.getExternalWorkspaces=void 0;var Ie=ce();Object.defineProperty(W,"getExternalWorkspaces",{enumerable:!0,get:function(){return Ie.getExternalWorkspaces}})});var Ge={};Fe(Ge,{default:()=>Ve});var A=l("@yarnpkg/cli"),P=l("@yarnpkg/core"),h=l("clipanion");var ge=l("@yarnpkg/core"),K=$(l("fs")),me=$(l("path"));var he=l("@yarnpkg/core");var pe=$(le()),ue=l("@yarnpkg/core"),J=$(l("path")),x="external:";function M(){return x}var Le=t=>t;function Ue(t){return J.default.posix.normalize(t)}var qe=process.platform==="win32"?t=>J.default.win32.normalize(t):Le;function Ne(t,e){return Ue(J.default.relative(t,e))}function u(t){return(0,pe.getExternalWorkspaces)(qe(t.cwd))}function fe(t){let e=t.indexOf("@",x.length+1);if(e===-1)throw new Error(`Invalid range: ${t}`);let o=t.slice(x.length,e),n=t.slice(e+1);return{name:o,version:n}}function de(t,e){if(e.startsWith(x)){let o=e.slice(x.length);return`${x}${t}@${o}`}return null}function I(t,e,o,n){let r={};t.workspacesByIdent.forEach(s=>{let{name:a,version:i,private:p}=s.manifest;if(a&&i&&!p){let c=ue.structUtils.stringifyIdent(a);r[c]={version:i,path:Ne(t.cwd,s.cwd)}}}),e.outputWorkspaces(r,o,n)}var{makeDescriptor:Be,makeLocator:ze,stringifyIdent:D}=he.structUtils,v=class t{constructor(){this.settings=null}static{this.protocol=M()}ensureSettings(e){this.settings||(this.settings=u(e.project))}finder(e){return this.settings?.findPackage(e)}trace(e){this.settings?.trace(e)}getResolutionDependencies(e,o){return this.trace(`UNEXPECTED: getResolutionDependencies called for ${D(e)}`),{}}supportsDescriptor(e,o){return e.range.startsWith(t.protocol)}supportsLocator(e,o){return e.reference.startsWith(t.protocol)}shouldPersistResolution(e,o){return!0}bindDescriptor(e,o,n){this.ensureSettings(n);let r=D(e),s=this.finder(r),a=de(r,e.range);if(!s||!a)throw Error(`Unknown external workspace "${r}:${t.protocol}" included by "${D(o)}"`);return this.trace(`Binding descriptor with '${a}'`),Be(e,a)}async getCandidates(e,o,n){return[ze(e,e.range)]}async getSatisfying(e,o,n,r){return this.ensureSettings(r),this.trace(`UNEXPECTEDP: getSatisfying called for ${D(e)}`),{locators:await this.getCandidates(e,o,r),sorted:!1}}async resolve(e,o){return this.ensureSettings(o),this.trace(`UNEXPECTED: Resolving external locator ${D(e)}`),{...e,name:e.name,version:"0.0.0",languageName:"unknown",conditions:null}}};var ke=v.protocol,Ke=ke+"*";function Ae(t,e){let o=new Set(Object.keys(t).filter(s=>t[s].startsWith(ke))),n=new Set,r=new Set;for(let s of e)o.has(s)||n.add(s);for(let s of o)e.has(s)||r.add(s);return{addedExternals:n,removedExternals:r}}function He(t,e,o,n){let r=me.default.join(t,"package.json"),s=JSON.parse(K.default.readFileSync(r,"utf8")),a=s.resolutions||{},{addedExternals:i,removedExternals:p}=Ae(a,e);if(i.size>0||p.size>0){n("Found changes to resolutions for external workspaces");for(let c of i)a[c]=Ke,n(`+ external workspace: ${c}`);for(let c of p)delete a[c],n(`- external workspace: ${c}`);if(!o){n(`Updating ${r} with changes to resolutions`);let c=Object.keys(a).sort().reduce((g,y)=>(g[y]=a[y],g),{});s.resolutions=c,K.default.writeFileSync(r,JSON.stringify(s,null,2))}}else n("No changes needed")}function ye(t,e){let{report:o,findPackage:n}=u(t),r=new Set,s=new Set,a=i=>{for(let p of i)for(let c of p.values())if(t.tryWorkspaceByDescriptor(c)===null){let g=ge.structUtils.stringifyIdent(c);n(g)&&(r.add(g),s.has(c)||s.add(c))}};t.workspacesByIdent.forEach(i=>{a([i.manifest.dependencies,i.manifest.devDependencies])});for(let i of s){let p=t.storedResolutions.get(i.descriptorHash);if(p){let c=t.storedPackages.get(p);c&&a([c.dependencies])}}He(t.cwd,r,e,o)}var L=class extends A.BaseCommand{constructor(){super(...arguments);this.target=h.Option.String("--target","",{description:"The path to the file to output the workspaces to"});this.checkOnly=h.Option.Boolean("--check-only",!1,{description:"Check if the workspaces have changed without writing the file"});this.includePrivate=h.Option.Boolean("--include-private",!1,{description:"Include private workspaces in the output"})}static{this.paths=[["external-workspaces","output"]]}static{this.usage=h.Command.Usage({category:"External Workspaces",description:"Output current workspace information to a json file",details:`
      This command will output the current set of workspaces to a json file. The file will not be modified if the workspaces have not changed.

      The path to the .json file can optionally have a set of keys appended to the end as a path. This will write the workspaces to a subpath of
      the file while maintaining the other contents of the file.
    `,examples:[["Output workspaces with settings from package.json","$0 external-workspaces output"],["Output workspaces to target","$0 external-workspaces output --target ./path/to/file.json"],["Output workspaces to target with a subpath","$0 external-workspaces output --target ./path/to/file.json/key1/key2"],["Check if workspaces have changed","$0 external-workspaces output --target ./path/to/file.json --check-only"]]})}async execute(){let o=await P.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await P.Project.find(o,this.context.cwd),r=u(n),s=this.target||r.outputPath;s&&await I(n,r,s,this.checkOnly)}},U=class extends A.BaseCommand{constructor(){super(...arguments);this.checkOnly=h.Option.Boolean("--check-only",!1,{description:"Check if the resolutions are up to date without writing the file"})}static{this.paths=[["external-workspaces","resolutions"]]}static{this.usage=h.Command.Usage({category:"External Workspaces",description:"Check if the workspace resolutions are up to date",details:`
      This command will check the current workspace resolutions against the external dependencies defined in the package.json.
    `,examples:[["Check resolutions with settings from package.json","$0 external-workspaces resolutions"]]})}async execute(){let o=await P.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await P.Project.find(o,this.context.cwd);await ye(n,this.checkOnly)}};var H=l("@yarnpkg/core"),O=l("@yarnpkg/fslib");var q=class t{constructor(){this.settings=null;this.fetcher=null;this.resolver=null;this.resolveOptions=null}static{this.protocol=M()}ensureSettings(e){return this.settings||(this.settings=u(e.project)),this.settings}supports(e,o){return e.reference.startsWith(t.protocol)}getLocalPath(e,o){return null}async fetch(e,o){let{name:n,version:r}=fe(e.reference),{findPackage:s,trace:a}=this.ensureSettings(o),i=O.npath.toPortablePath(s(n)?.path||"");return i?(a(`Found existing local path for ${n}: ${i}`),{packageFs:new O.CwdFS(i),prefixPath:O.PortablePath.dot,localPath:i}):await this.fetchFallback(n,r,o)}async fetchFallback(e,o,n){let r=H.structUtils.makeDescriptor(H.structUtils.parseIdent(e),o);this.resolver??=n.project.configuration.makeResolver(),this.fetcher??=n.project.configuration.makeFetcher(),this.resolveOptions??={project:n.project,resolver:this.resolver,fetchOptions:n,report:n.report};let s=await this.resolver.getCandidates(r,{},this.resolveOptions);if(s.length===0)throw new Error(`No candidate found on npm for "${e}" : "${o}"`);let a=s[0];return await this.fetcher.fetch(a,n)}};function we(t,e){let o=u(t);!o.outputOnlyOnCommand&&o.outputPath&&I(t,o)}var Xe={fetchers:[q],resolvers:[v],hooks:{afterAllInstalled:we},commands:[L,U]},Ve=Xe;return De(Ge);})();
return plugin;
}
};
//# sourceMappingURL=external-workspaces.cjs.map
