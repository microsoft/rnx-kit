// @ts-check
import got from "got";
import * as fs from "node:fs";
import * as module from "node:module";
import ts from "typescript";

const compatData = "https://unpkg.com/@mdn/browser-compat-data/data.json";

// https://developer.mozilla.org/en-US/docs/Web/API
const ignoredSpecs = [
  "https://dom.spec.whatwg.org/", // DOM
  "https://drafts.css-houdini.org/", // CSS Houdini
  "https://drafts.fxtf.org/", // W3C CSS-SVG effects
  "https://html.spec.whatwg.org/multipage/browsing-the-web.html", // HTML
  "https://html.spec.whatwg.org/multipage/canvas.html", // Canvas
  "https://html.spec.whatwg.org/multipage/common-dom-interfaces.html", // DOM
  "https://html.spec.whatwg.org/multipage/custom-elements.html", // DOM
  "https://html.spec.whatwg.org/multipage/dom.html", // DOM
  "https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html", // DOM
  "https://html.spec.whatwg.org/multipage/edits.html", // DOM
  "https://html.spec.whatwg.org/multipage/embedded-content.html", // DOM
  "https://html.spec.whatwg.org/multipage/form-control-infrastructure.html", // DOM
  "https://html.spec.whatwg.org/multipage/form-elements.html", // DOM
  "https://html.spec.whatwg.org/multipage/forms.html", // DOM
  "https://html.spec.whatwg.org/multipage/grouping-content.html", // DOM
  "https://html.spec.whatwg.org/multipage/history.html", // DOM
  "https://html.spec.whatwg.org/multipage/iframe-embed-object.html", // DOM
  "https://html.spec.whatwg.org/multipage/image-maps.html", // DOM
  "https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html", // DOM
  "https://html.spec.whatwg.org/multipage/input.html", // DOM
  "https://html.spec.whatwg.org/multipage/interaction.html", // DOM
  "https://html.spec.whatwg.org/multipage/interactive-elements.html", // DOM
  "https://html.spec.whatwg.org/multipage/media.html", // DOM
  "https://html.spec.whatwg.org/multipage/obsolete.html", // DOM
  "https://html.spec.whatwg.org/multipage/parsing.html", // DOM
  "https://html.spec.whatwg.org/multipage/scripting.html", // DOM
  "https://html.spec.whatwg.org/multipage/sections.html", // DOM
  "https://html.spec.whatwg.org/multipage/semantics.html", // DOM
  "https://html.spec.whatwg.org/multipage/tables.html", // DOM
  "https://html.spec.whatwg.org/multipage/text-level-semantics.html", // DOM
  "https://html.spec.whatwg.org/multipage/web-messaging.html", // Broadcast
  "https://html.spec.whatwg.org/multipage/window-object.html#htmldocument", // HTMLDocument
  "https://html.spec.whatwg.org/multipage/workers.html", // Workers
  "https://immersive-web.github.io/", // WebXR
  "https://registry.khronos.org/", // WebGL
  "https://svgwg.org/", // SVG
  "https://w3c.github.io/DOM-Parsing/", // XMLSerializer
  "https://w3c.github.io/IntersectionObserver/", // IntersectionObserver
  "https://w3c.github.io/ServiceWorker/", // ServiceWorker
  "https://w3c.github.io/csswg-drafts/", // CSS
  "https://w3c.github.io/mathml-core/", // MathML
  "https://w3c.github.io/mediacapture-fromelement", // Canvas
  "https://w3c.github.io/uievents/", // DOM events
  "https://webidl.spec.whatwg.org/", // DOMException
  "https://xhr.spec.whatwg.org/#dom-formdata", // XMLHttpRequest
];

/**
 * @typedef {{
 *   error: typeof console.error;
 *   info: typeof console.info;
 *   warn: typeof console.warn;
 * }} Logger;
 *
 * @typedef {{
 *   version_added: string | boolean;
 *   version_removed?: string;
 *   alternative_name?: string;
 * }} Support;
 *
 * @typedef {{
 *   spec_url?: string | string[];
 *   status: {
 *     deprecated: boolean;
 *     experimental: boolean;
 *     standard_track: boolean;
 *   };
 *   support: Record<string, Support | Support[]>
 * }} Spec;
 */

/**
 * @param {ts.ParameterDeclaration | ts.PropertySignature | ts.MethodSignature} node
 * @returns {string | null}
 */
function getTypeName(node) {
  if (
    !node.type ||
    !ts.isTypeReferenceNode(node.type) ||
    !ts.isIdentifier(node.type.typeName)
  ) {
    return null;
  }

  return node.type.typeName.text;
}

/**
 * Returns whether the spec if deprecated, experimental, or otherwise unstable,
 * and whether it comes from a domain that we currently don't care about.
 *
 * @see {@link ignoredSpecs}
 *
 * @param {Spec} spec
 * @returns {boolean}
 */
function isIgnored({ spec_url, status }) {
  if (status.deprecated || status.experimental || !status.standard_track) {
    return true;
  }

  if (Array.isArray(spec_url)) {
    return spec_url.some((spec) =>
      ignoredSpecs.some((url) => spec.startsWith(url))
    );
  } else if (typeof spec_url === "string") {
    return ignoredSpecs.some((url) => spec_url.startsWith(url));
  }

  return !spec_url;
}

/**
 * Load the baseline generated by the TypeScript team.
 * @see {@link https://github.com/microsoft/TypeScript-DOM-lib-generator}
 * @returns {ts.SourceFile | null}
 */
function loadBaseline() {
  const require = module.createRequire(import.meta.url);
  const lib = require.resolve("typescript/lib/lib.dom.d.ts");
  const def = fs.readFileSync(lib, { encoding: "utf-8" });
  return ts.createSourceFile("lib.native.d.ts", def, ts.ScriptTarget.ESNext);
}

/**
 * @param {ts.SourceFile} node
 * @returns {string}
 */
function serialize(node) {
  return ts
    .createPrinter({ newLine: ts.NewLineKind.LineFeed })
    .printNode(ts.EmitHint.SourceFile, node, node);
}

/**
 * Generates interfaces from browser compatiblity data.
 * @param {string} address
 * @param {Logger} logger
 */
async function derive(address, logger) {
  logger.info("Loading baseline");
  const baseline = loadBaseline();
  if (!baseline) {
    logger.error("Failed to load baseline");
    process.exitCode = 1;
    return;
  }

  logger.info("Loading browser compatibility data");
  const { api } = await got(address).json();
  const included = new Set();
  for (const [name, spec] of Object.entries(api)) {
    const compat = spec.__compat;
    if (!isIgnored(compat)) {
      included.add(name);
    }
  }

  logger.info("Generating interfaces");

  /*
   Step 1: Filter out variables that we don't care about. Also put all
           interfaces somewhere easily accessible.
   */

  /** @type {Record<string, ts.InterfaceDeclaration>} */
  const interfaces = {};
  /** @type {ts.VariableStatement[]} */
  const globals = [];

  for (const node of baseline.statements) {
    if (ts.isVariableStatement(node)) {
      // declare var AudioBuffer: {...};
      for (const decl of node.declarationList.declarations) {
        if (ts.isIdentifier(decl.name) && included.has(decl.name.text)) {
          globals.push(node);
          break;
        }
      }
    } else if (ts.isInterfaceDeclaration(node)) {
      // interface AudioBuffer {...}
      if (included.has(node.name.text)) {
        interfaces[node.name.text] = node;
      }
    }
  }

  /*
   Step 2: Iterate over variables and keep only used interfaces.
   */

  /** @type {Record<string, ts.Statement>} */
  const statements = {};

  /** @type {(node: ts.ParameterDeclaration | ts.TypeElement) => void} */
  const visitNode = (node) => {
    if (ts.isMethodSignature(node)) {
      for (const param of node.parameters) {
        visitNode(param);
      }
    } else if (!ts.isParameter(node) && !ts.isPropertySignature(node)) {
      return;
    }

    const typeName = getTypeName(node);
    if (typeName && interfaces[typeName]) {
      const node = interfaces[typeName];
      delete interfaces[typeName];

      for (const member of node.members) {
        visitNode(member);
      }

      statements[typeName] = node;
    }
  };

  for (const node of globals) {
    for (const decl of node.declarationList.declarations) {
      const name = ts.isIdentifier(decl.name) ? decl.name.text : "";
      if (
        !name ||
        statements[name] ||
        !decl.type ||
        !ts.isTypeLiteralNode(decl.type)
      ) {
        continue;
      }

      for (const member of decl.type.members) {
        visitNode(member);
      }
    }
  }

  /*
   Step 3: Modify the baseline and write to disk.
   */

  // @ts-expect-error Cannot assign to 'statements' because it is a read-only property.
  baseline.statements = [...Object.values(statements), ...globals];

  const manifest = fs.readFileSync("package.json", { encoding: "utf-8" });
  const { types } = JSON.parse(manifest);
  logger.info(`Writing '${types}'`);
  fs.writeFileSync(types, serialize(baseline));
}

/**
 * @param {string} address
 * @param {boolean} verbose
 */
function main(address, verbose) {
  const { error, info, warn } = console;
  const logger = verbose
    ? { error, info, warn }
    : { error, info: () => 0, warn };
  return derive(address, logger);
}

main(compatData, process.argv.includes("--verbose"));
