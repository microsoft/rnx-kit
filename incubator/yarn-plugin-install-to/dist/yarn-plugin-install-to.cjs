/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-install-to",
factory: function (require) {
"use strict";var plugin=(()=>{var u=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var m=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(o,s)=>(typeof require<"u"?require:o)[s]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var L=(e,o)=>{for(var s in o)u(e,s,{get:o[s],enumerable:!0})},R=(e,o,s,t)=>{if(o&&typeof o=="object"||typeof o=="function")for(let a of b(o))!x.call(e,a)&&a!==s&&u(e,a,{get:()=>o[a],enumerable:!(t=P(o,a))||t.enumerable});return e};var I=e=>R(u({},"__esModule",{value:!0}),e);var E={};L(E,{default:()=>C});var f=m("@yarnpkg/cli"),r=m("@yarnpkg/core"),c=m("clipanion"),d=class extends f.BaseCommand{constructor(){super(...arguments);this.verbose=c.Option.Boolean("--verbose",!1,{description:"Report out verbose logs of the install process"});this.workspaceNames=c.Option.Rest({required:1})}static{this.paths=[["install-to"]]}static{this.usage=c.Command.Usage({description:"Download and install only the packages required for the given workspace or workspaces",details:`
      Given the name of one or more project workspaces, this command will install only the packages required for those workspaces.
      This is primarily useful for a focused CI build that builds a subset of a large monorepo.

      Note that this will use the lockfile as is, running the resolution step such that the data in the lockfile is trusted as-is. The command
      is optimized for speed of install, assuming that previous standard install commands will have been run to ensure the lockfile is up to date and correct.
    `,examples:[["Install a single package and its dependencies","$0 install-to workspace-package-name"],["Install multiple packages and their dependencies","$0 install-to @my-scope/workspace-package-1 @my-scope/workspace-package-2"]]})}async execute(){let{stdout:s}=this.context,t=await r.Configuration.find(this.context.cwd,this.context.plugins),{project:a,workspace:n}=await r.Project.find(t,this.context.cwd),i=await r.Cache.find(t),p=S(this.workspaceNames,a);if(p.size===0)throw new c.UsageError("No valid workspaces specified. Please provide one or more workspace names");if(!n)throw new f.WorkspaceRequiredError(a.cwd,this.context.cwd);return await a.restoreInstallState({restoreResolutions:!1}),(await r.StreamReport.start({configuration:t,stdout:s,includeLogs:!0,includeVersion:!0},async l=>{if(this.verbose)for(let g of p){let v=r.structUtils.prettyWorkspace(t,g);l.reportInfo(0,`Installing workspace ${v} (${g.cwd})`)}await D(a,t,p,{cache:i,report:l,immutable:!0},this.verbose)})).exitCode()}};function S(e,o){let s=new Set;for(let t of e){let a=o.tryWorkspaceByIdent(r.structUtils.parseIdent(t));if(!a)throw new c.UsageError(`Unable to find workspace for ${t}. Please ensure the workspace name is correct`);s.add(a);let n=a.getRecursiveWorkspaceDependencies();for(let i of n)s.add(i)}return s.add(o.topLevelWorkspace),s}function y(e,o){let s=e.project.storedResolutions.get(o);if(s){let t=!e.accessibleLocators.has(s);return e.storedResolutions.set(o,s),e.accessibleLocators.add(s),t?e.project.storedPackages.get(s):void 0}}function h(e,o){let s=y(e,o.descriptorHash);if(s)for(let[,t]of s.dependencies)h(e,t)}function H(e,o){let s={project:e,accessibleLocators:new Set,storedResolutions:new Map};for(let t of o){let n=y(s,t.anchoredDescriptor.descriptorHash)?.dependencies??t.manifest.dependencies;for(let[,i]of n)h(s,i);for(let[,i]of t.manifest.devDependencies)h(s,i)}e.accessibleLocators=s.accessibleLocators,e.storedResolutions=s.storedResolutions}async function D(e,o,s,t,a=!1){let{report:n}=t,i=await o.getPackageExtensions();for(let w of i.values())for(let[,l]of w)for(let k of l)k.status=r.PackageExtensionStatus.Inactive;await n.startTimerPromise("Resolution step",async()=>{await e.resolveEverything(t)});let p=e.accessibleLocators.size;H(e,s),a&&n.reportInfo(0,`Trimming from ${p} to ${e.accessibleLocators.size} locators`),await n.startTimerPromise("Fetch step",async()=>{await e.fetchEverything(t)}),await n.startTimerPromise("Link step",async()=>{await e.linkEverything(t)}),await e.persistInstallStateFile()}var W={commands:[d]},C=W;return I(E);})();
return plugin;
}
};
//# sourceMappingURL=yarn-plugin-install-to.cjs.map
