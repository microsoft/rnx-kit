/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-install-to",
factory: function (require) {
"use strict";var plugin=(()=>{var y=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var C=Object.prototype.hasOwnProperty;var f=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(s,o)=>(typeof require<"u"?require:s)[o]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var D=(e,s)=>{for(var o in s)y(e,o,{get:s[o],enumerable:!0})},L=(e,s,o,t)=>{if(s&&typeof s=="object"||typeof s=="function")for(let a of S(s))!C.call(e,a)&&a!==o&&y(e,a,{get:()=>s[a],enumerable:!(t=R(s,a))||t.enumerable});return e};var E=e=>L(y({},"__esModule",{value:!0}),e);var z={};D(z,{default:()=>B});var m=f("@yarnpkg/cli"),c=f("@yarnpkg/core"),w=f("clipanion"),h=class extends m.BaseCommand{constructor(){super(...arguments);this.verbose=w.Option.Boolean("--verbose",!1,{description:"Report out verbose logs of the download process"})}static{this.paths=[["download"]]}static{this.usage=w.Command.Usage({description:"Download and cache all packages without installing (offline preparation)",details:`
      This command runs through the resolution and fetch process to download all packages
      and prepare them in the .yarn/cache folder. It does NOT create node_modules or any
      symlinks, making it ideal for preparing an offline cache.

      This is useful for:
      - Pre-populating the cache before going offline
      - Creating a cache for CI/CD systems
      - Preparing packages for later offline installation

      The command will:
      1. Resolve all dependencies using the lockfile
      2. Download and prepare all packages in .yarn/cache
      3. Skip the link step entirely (no node_modules)
    `,examples:[["Download all packages for offline use","$0 download"],["Download with verbose logging","$0 download --verbose"]]})}async execute(){let{stdout:o}=this.context,t=await c.Configuration.find(this.context.cwd,this.context.plugins),{project:a,workspace:n}=await c.Project.find(t,this.context.cwd),i=await c.Cache.find(t);if(!n)throw new m.WorkspaceRequiredError(a.cwd,this.context.cwd);return await a.restoreInstallState({restoreResolutions:!1}),(await c.StreamReport.start({configuration:t,stdout:o,includeLogs:!0,includeVersion:!0},async d=>{this.verbose&&d.reportInfo(0,"Starting download of all packages to cache"),await O(a,t,{cache:i,report:d,immutable:!0},this.verbose)})).exitCode()}};async function O(e,s,o,t=!1){let{report:a}=o,n=await s.getPackageExtensions();for(let i of n.values())for(let[,l]of i)for(let d of l)d.status=c.PackageExtensionStatus.Inactive;await a.startTimerPromise("Resolution step",async()=>{await e.resolveEverything(o)}),t&&a.reportInfo(0,`Resolved ${e.storedResolutions.size} packages with ${e.accessibleLocators.size} unique locators`),await a.startTimerPromise("Fetch step",async()=>{await e.fetchEverything(o)}),t&&a.reportInfo(0,`Downloaded and cached ${e.accessibleLocators.size} packages`),t&&a.reportInfo(0,"Skipping link step - packages are cached and ready for offline installation"),await e.persistInstallStateFile()}var k=f("@yarnpkg/cli"),r=f("@yarnpkg/core"),p=f("clipanion"),g=class extends k.BaseCommand{constructor(){super(...arguments);this.verbose=p.Option.Boolean("--verbose",!1,{description:"Report out verbose logs of the install process"});this.workspaceNames=p.Option.Rest({required:1})}static{this.paths=[["install-to"]]}static{this.usage=p.Command.Usage({description:"Download and install only the packages required for the given workspace or workspaces",details:`
      Given the name of one or more project workspaces, this command will install only the packages required for those workspaces.
      This is primarily useful for a focused CI build that builds a subset of a large monorepo.

      Note that this will use the lockfile as is, running the resolution step such that the data in the lockfile is trusted as-is. The command
      is optimized for speed of install, assuming that previous standard install commands will have been run to ensure the lockfile is up to date and correct.
    `,examples:[["Install a single package and its dependencies","$0 install-to workspace-package-name"],["Install multiple packages and their dependencies","$0 install-to @my-scope/workspace-package-1 @my-scope/workspace-package-2"]]})}async execute(){let{stdout:o}=this.context,t=await r.Configuration.find(this.context.cwd,this.context.plugins),{project:a,workspace:n}=await r.Project.find(t,this.context.cwd),i=await r.Cache.find(t),l=T(this.workspaceNames,a);if(l.size===0)throw new p.UsageError("No valid workspaces specified. Please provide one or more workspace names");if(!n)throw new k.WorkspaceRequiredError(a.cwd,this.context.cwd);return await a.restoreInstallState({restoreResolutions:!1}),(await r.StreamReport.start({configuration:t,stdout:o,includeLogs:!0,includeVersion:!0},async u=>{if(this.verbose)for(let P of l){let I=r.structUtils.prettyWorkspace(t,P);u.reportInfo(0,`Installing workspace ${I} (${P.cwd})`)}await W(a,t,l,{cache:i,report:u,immutable:!0},this.verbose)})).exitCode()}};function T(e,s){let o=new Set;for(let t of e){let a=s.tryWorkspaceByIdent(r.structUtils.parseIdent(t));if(!a)throw new p.UsageError(`Unable to find workspace for ${t}. Please ensure the workspace name is correct`);o.add(a);let n=a.getRecursiveWorkspaceDependencies();for(let i of n)o.add(i)}return o.add(s.topLevelWorkspace),o}function b(e,s){let o=e.project.storedResolutions.get(s);if(o){let t=!e.accessibleLocators.has(o);return e.storedResolutions.set(s,o),e.accessibleLocators.add(o),t?e.project.storedPackages.get(o):void 0}}function v(e,s){let o=b(e,s.descriptorHash);if(o)for(let t of o.dependencies.values())v(e,t)}function $(e,s){let o={project:e,accessibleLocators:new Set,storedResolutions:new Map};for(let t of s){let n=b(o,t.anchoredDescriptor.descriptorHash)?.dependencies??t.manifest.dependencies;for(let i of n.values())v(o,i);for(let i of t.manifest.devDependencies.values())v(o,i)}e.accessibleLocators=o.accessibleLocators,e.storedResolutions=o.storedResolutions}async function W(e,s,o,t,a=!1){let{report:n}=t,i=await s.getPackageExtensions();for(let d of i.values())for(let[,u]of d)for(let x of u)x.status=r.PackageExtensionStatus.Inactive;await n.startTimerPromise("Resolution step",async()=>{await e.resolveEverything(t)});let l=e.accessibleLocators.size;$(e,o),a&&n.reportInfo(0,`Trimming from ${l} to ${e.accessibleLocators.size} locators`),await n.startTimerPromise("Fetch step",async()=>{await e.fetchEverything(t)}),await n.startTimerPromise("Link step",async()=>{await e.linkEverything(t)}),await e.persistInstallStateFile()}var H={commands:[g,h]},B=H;return E(z);})();
return plugin;
}
};
//# sourceMappingURL=yarn-plugin-install-to.cjs.map
