{
  "version": 3,
  "sources": ["../src/index.ts", "../src/installTo.ts"],
  "sourcesContent": ["import { type Plugin } from \"@yarnpkg/core\";\nimport { InstallTo } from \"./installTo\";\n\n/**\n * The plugin definition.\n */\nconst plugin: Plugin = {\n  commands: [InstallTo],\n};\n\n// eslint-disable-next-line no-restricted-exports\nexport default plugin;\n", "import { BaseCommand, WorkspaceRequiredError } from \"@yarnpkg/cli\";\nimport {\n  Cache,\n  Configuration,\n  type Descriptor,\n  type DescriptorHash,\n  type LocatorHash,\n  type Package,\n  PackageExtensionStatus,\n  Project,\n  StreamReport,\n  structUtils,\n  type Workspace,\n} from \"@yarnpkg/core\";\nimport { Command, Option, UsageError } from \"clipanion\";\n\ntype InstallOptions = {\n  cache: Cache;\n  report: StreamReport;\n  lockfileOnly?: boolean;\n  immutable?: boolean;\n};\n\ntype ProjectScopingOptions = {\n  project: Project;\n  accessibleLocators: Set<LocatorHash>;\n  storedResolutions: Map<DescriptorHash, LocatorHash>;\n};\n\nexport class InstallTo extends BaseCommand {\n  static override paths = [[\"install-to\"]];\n\n  static override usage = Command.Usage({\n    description:\n      \"Download and install only the packages required for the given workspace or workspaces\",\n    details: `\n      Given the name of one or more project workspaces, this command will install only the packages required for those workspaces.\n      This is primarily useful for a focused CI build that builds a subset of a large monorepo.\n\n      Note that this will use the lockfile as is, running the resolution step such that the data in the lockfile is trusted as-is. The command\n      is optimized for speed of install, assuming that previous standard install commands will have been run to ensure the lockfile is up to date and correct.\n    `,\n    examples: [\n      [\n        \"Install a single package and its dependencies\",\n        \"$0 install-to workspace-package-name\",\n      ],\n      [\n        \"Install multiple packages and their dependencies\",\n        \"$0 install-to @my-scope/workspace-package-1 @my-scope/workspace-package-2\",\n      ],\n    ],\n  });\n\n  verbose = Option.Boolean(\"--verbose\", false, {\n    description: \"Report out verbose logs of the install process\",\n  });\n\n  workspaceNames = Option.Rest({ required: 1 });\n\n  async execute() {\n    const { stdout } = this.context;\n    const configuration = await Configuration.find(\n      this.context.cwd,\n      this.context.plugins\n    );\n    const { project, workspace } = await Project.find(\n      configuration,\n      this.context.cwd\n    );\n    const cache = await Cache.find(configuration);\n    const workspaces = workspacesFromNames(this.workspaceNames, project);\n\n    // need to have at least one specified workspace to install to\n    if (workspaces.size === 0) {\n      throw new UsageError(\n        `No valid workspaces specified. Please provide one or more workspace names`\n      );\n    }\n    // also needs to be a valid project with a workspace setup\n    if (!workspace) {\n      throw new WorkspaceRequiredError(project.cwd, this.context.cwd);\n    }\n\n    await project.restoreInstallState({\n      restoreResolutions: false,\n    });\n\n    /**\n     * Create one of yarn's stream report to wrap the output of the install process\n     */\n    const report = await StreamReport.start(\n      {\n        configuration,\n        stdout,\n        includeLogs: true,\n        includeVersion: true,\n      },\n      async (report) => {\n        if (this.verbose) {\n          for (const workspace of workspaces) {\n            const name = structUtils.prettyWorkspace(configuration, workspace);\n            report.reportInfo(\n              0,\n              `Installing workspace ${name} (${workspace.cwd})`\n            );\n          }\n        }\n        const options = { cache, report, immutable: true };\n        await partialInstall(\n          project,\n          configuration,\n          workspaces,\n          options,\n          this.verbose\n        );\n      }\n    );\n\n    return report.exitCode();\n  }\n}\n\nfunction workspacesFromNames(\n  names: string[],\n  project: Project\n): Set<Workspace> {\n  const workspaces = new Set<Workspace>();\n  for (const name of names) {\n    const workspace = project.getWorkspaceByIdent(structUtils.parseIdent(name));\n    workspaces.add(workspace);\n    const dependencies = workspace.getRecursiveWorkspaceDependencies();\n    for (const dependency of dependencies) {\n      workspaces.add(dependency);\n    }\n  }\n  // add the root workspace as well\n  workspaces.add(project.topLevelWorkspace);\n  return workspaces;\n}\n\nfunction getResolution(\n  options: ProjectScopingOptions,\n  hash: DescriptorHash\n): Package | undefined {\n  const locatorHash = options.project.storedResolutions.get(hash);\n  if (locatorHash) {\n    const newHash = !options.accessibleLocators.has(locatorHash);\n    options.storedResolutions.set(hash, locatorHash);\n    options.accessibleLocators.add(locatorHash);\n    return newHash\n      ? options.project.storedPackages.get(locatorHash)\n      : undefined;\n  }\n  return undefined;\n}\n\nfunction traverseDependencies(\n  options: ProjectScopingOptions,\n  descriptor: Descriptor\n) {\n  const pkg = getResolution(options, descriptor.descriptorHash);\n  if (pkg) {\n    for (const [, dependency] of pkg.dependencies) {\n      traverseDependencies(options, dependency);\n    }\n  }\n}\n\nfunction pareDownProject(project: Project, workspaces: Set<Workspace>) {\n  const options: ProjectScopingOptions = {\n    project,\n    accessibleLocators: new Set<LocatorHash>(),\n    storedResolutions: new Map<DescriptorHash, LocatorHash>(),\n  };\n\n  for (const workspace of workspaces) {\n    const pkg = getResolution(\n      options,\n      workspace.anchoredDescriptor.descriptorHash\n    );\n\n    const dependencies = pkg\n      ? pkg.dependencies\n      : workspace.manifest.dependencies;\n    for (const [, descriptor] of dependencies) {\n      traverseDependencies(options, descriptor);\n    }\n    for (const [, descriptor] of workspace.manifest.devDependencies) {\n      traverseDependencies(options, descriptor);\n    }\n  }\n\n  project.accessibleLocators = options.accessibleLocators;\n  project.storedResolutions = options.storedResolutions;\n}\n\nasync function partialInstall(\n  project: Project,\n  configuration: Configuration,\n  workspaces: Set<Workspace>,\n  opts: InstallOptions,\n  verbose = false\n): Promise<void> {\n  const { report } = opts;\n\n  const packageExtensions = await configuration.getPackageExtensions();\n\n  for (const extensionsByIdent of packageExtensions.values())\n    for (const [, extensionsByRange] of extensionsByIdent)\n      for (const extension of extensionsByRange)\n        extension.status = PackageExtensionStatus.Inactive;\n\n  await report.startTimerPromise(`Resolution step`, async () => {\n    await project.resolveEverything(opts);\n  });\n\n  const priorLocatorCount = project.accessibleLocators.size;\n  pareDownProject(project, workspaces);\n  if (verbose) {\n    report.reportInfo(\n      0,\n      `Trimming from ${priorLocatorCount} to ${project.accessibleLocators.size} locators`\n    );\n  }\n\n  await report.startTimerPromise(`Fetch step`, async () => {\n    await project.fetchEverything(opts);\n  });\n\n  await report.startTimerPromise(`Link step`, async () => {\n    await project.linkEverything(opts);\n  });\n\n  await project.persistInstallStateFile();\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "index_default", "import_cli", "import_core", "import_clipanion", "InstallTo", "stdout", "configuration", "project", "workspace", "cache", "workspaces", "workspacesFromNames", "report", "name", "partialInstall", "names", "dependencies", "dependency", "getResolution", "options", "hash", "locatorHash", "newHash", "traverseDependencies", "descriptor", "pkg", "pareDownProject", "opts", "verbose", "packageExtensions", "extensionsByIdent", "extensionsByRange", "extension", "priorLocatorCount", "plugin", "InstallTo", "index_default"]
}
