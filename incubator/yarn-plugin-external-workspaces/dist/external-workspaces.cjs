/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@rnx-kit/yarn-plugin-external-workspaces",
factory: function (require) {
"use strict";var plugin=(()=>{var mt=Object.create;var b=Object.defineProperty;var kt=Object.getOwnPropertyDescriptor;var yt=Object.getOwnPropertyNames;var Pt=Object.getPrototypeOf,vt=Object.prototype.hasOwnProperty;var i=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(t,e)=>(typeof require<"u"?require:t)[e]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+r+'" is not supported')});var wt=(r,t)=>{for(var e in t)b(r,e,{get:t[e],enumerable:!0})},G=(r,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of yt(t))!vt.call(r,s)&&s!==e&&b(r,s,{get:()=>t[s],enumerable:!(o=kt(t,s))||o.enumerable});return r};var C=(r,t,e)=>(e=r!=null?mt(Pt(r)):{},G(t||!r||!r.__esModule?b(e,"default",{value:r,enumerable:!0}):e,r)),xt=r=>G(b({},"__esModule",{value:!0}),r);var Et={};wt(Et,{default:()=>Wt});var I=i("@yarnpkg/core"),k=i("@yarnpkg/fslib"),F=C(i("fs")),q=C(i("path"));var V="externalWorkspacesProvider",X="externalWorkspacesOutputPath",z="externalWorkspacesOutputOnlyOnCommand",Q={[V]:{description:"Relative path to a .json file of shape WorkspaceOutputJson or a .js file that exports a function of type DefinitionFinder as the default export",type:I.SettingsType.STRING,default:null},[X]:{description:"Relative path to a .json file where workspace info should be recorded. If a directory is provided the file will pick up the name from the root package.json",type:I.SettingsType.STRING,default:null},[z]:{description:"Suppress writing out the workspaces on install and only write them out when the command is invoked",type:I.SettingsType.BOOLEAN,default:!1}};function Y(r,t){let e=t?k.npath.fromPortablePath(t):"",o=q.default.join(e,typeof r=="string"?r:"");return k.npath.toPortablePath(o)}function y(r){let{projectCwd:t}=r,e=Y(r.get(V),t),o=Y(r.get(X),t),s=!!r.get(z);return{provider:e,outputPath:o,outputOnlyOnCommand:s}}function Z(r){if(!F.default.existsSync(r))throw new Error(`Unable to find external workspaces definition file ${r}`);let t=JSON.parse(F.default.readFileSync(r,"utf8"))?.generated||{},e=typeof t.generated=="object"?t.generated:{},{repoPath:o="",workspaces:s={}}=e,n=k.npath.toPortablePath(o);return a=>{let c=s[a];return c?{path:k.ppath.join(n,k.npath.toPortablePath(c))}:null}}function tt(r){if(!F.default.existsSync(r))throw new Error(`Unable to find external workspaces definition file ${r}`);let t=i(r).default;if(typeof t!="function")throw new Error(`External workspaces definition file ${r} does not export a function as default`);return t}var x=i("@yarnpkg/fslib");var v=i("@yarnpkg/core"),p=i("@yarnpkg/fslib"),it=C(i("fs"));var M=i("@yarnpkg/core");function et(r){let t=r.indexOf(":");return t!==-1?{protocol:r.slice(0,t+1),version:r.slice(t+1)}:{protocol:"",version:r}}function rt(r,t){if(r.range.startsWith(t))return r;let{version:e}=et(r.range);return M.structUtils.makeDescriptor(r,`${t}${e}`)}function ot(r,t){let{protocol:e,version:o}=et(r.reference);return e===t?r:M.structUtils.makeLocator(r,`${t}${o}`)}var P="external:",E="fallback:",st="npm:",nt=[P,E,st],Ot=nt.map(r=>r.slice(0,-1)+"Dependency"),at=[E,P,st],Lt=at.map(r=>r.slice(0,-1)+"Dependency"),W=class{constructor(t,e,o,s){this.packages=[null,null,null];this.localIndex=0;this.remoteIndex=1;this.fallbackIndex=2;this.name=t,this.localPath=o,this.isLocal=!!o,this.prettyName=e,this.trace=s,this.protocols=this.isLocal?nt:at,this.dependentKeys=this.isLocal?Ot:Lt,this.isLocal||(this.localIndex=1,this.remoteIndex=0)}getResolutionDependencies(t,e){let o=this.indexFromResolverType(e)+1;return{[this.dependentKeys[o]]:this.transformDescriptor(t,o)}}async getCandidates(t,e,o,s){let n=this.indexFromResolverType(s),[a,c]=this.getNextDependencies(e,n),l=o.resolver,u=this.transformDescriptor(t,n+1),f=await l.getCandidates(u,a,o),m=f.length>0;return m&&c&&f.push(c),(n===0||f.length===0)&&this.trace(`${this.prettyName}: getCandidates: (${s}) found ${f.length} locators from ${m?"child":"package"}`),this.transformLocators(f,this.resolverLocatorIndex(s))}async getSatisfying(t,e,o,s,n){let a=this.indexFromResolverType(n),c=a+1,[l]=this.getNextDependencies(e,a),u=this.transformDescriptor(t,c),f=this.transformLocators(o,c),d=await s.resolver.getSatisfying(u,l,f,s),D=this.resolverLocatorIndex(n);return D!==c&&(d.locators=this.transformLocators(d.locators,D)),(a===0||d.locators.length===0)&&this.trace(`${this.prettyName}: getSatisfying (${n}) found ${d.locators.length} locators from ${o.length} inputs`),d}toFallbackLocator(t){return this.transformLocator(t,this.fallbackIndex)}toLeadDescriptor(t){return this.transformDescriptor(t,0)}indexFromResolverType(t){return t==="local"?this.localIndex:this.remoteIndex}resolverLocatorIndex(t){return t==="local"?this.localIndex:this.fallbackIndex}transformDescriptor(t,e){return rt(t,this.protocols[e])}transformLocator(t,e){return ot(t,this.protocols[e])}transformLocators(t,e){return t.map(o=>this.transformLocator(o,e))}getNextDependencies(t,e){let o=e+1,s=t[this.dependentKeys[o]];s&&this.packages[o]===null&&(this.packages[o]=s);let n=this.packages[o],a={};return n&&(a[this.dependentKeys[o]]=n),[a,n]}};var _=r=>null,Rt=p.npath.toPortablePath("package.json"),Dt=p.npath.toPortablePath(""),J=class{constructor(t){this.trace=_;this.workspaceMap=new Map;this.workspaceByIdent=new Map;this.notExternal=new Set;this.npmPackageByIdent=new Map;this.resolver=null;this.fetcher=null;this.findPackage=_;this.pathOffset=p.npath.toPortablePath("");this.trace=_,this.report=o=>console.log(o),this.root=t.cwd,this.project=t;let{provider:e}=y(t.configuration);e&&(e.endsWith(".json")?(this.pathOffset=this.findConfigPathOffset(e),this.findPackage=Z(e)):(e.endsWith(".js")||e.endsWith(".cjs"))&&(this.pathOffset=this.findConfigPathOffset(e),this.findPackage=tt(e)))}findConfigPathOffset(t){let e=p.ppath.dirname(t);return p.ppath.relative(this.root,e)}tryNameLookup(t){return this.workspaceMap.get(t)||null}createWorkspace(t,e){let o=v.structUtils.prettyIdent(this.project.configuration,v.structUtils.parseIdent(t));return new W(t,o,e,this.trace)}tryIdentLoad(t){let e=v.structUtils.stringifyIdent(t),o=this.tryNameLookup(e);if(o)return this.workspaceByIdent.set(t.identHash,o),o;let s=this.findPackage(e);if(s){let n=p.npath.toPortablePath(s.path||"");return n&&(p.ppath.isAbsolute(n)||(n=p.ppath.join(this.root,this.pathOffset,n),it.default.existsSync(p.ppath.join(n,Rt))||(n=Dt))),o=this.createWorkspace(e,n),this.trace(`Loaded external workspace ${o.prettyName} of type ${s.path?"LOCAL":"REMOTE"}`),this.workspaceMap.set(e,o),this.workspaceByIdent.set(t.identHash,o),o}return this.notExternal.add(t.identHash),null}setFallbackPackage(t,e){this.npmPackageByIdent.set(t.identHash,e)}getFallbackPackage(t){return this.npmPackageByIdent.get(t.identHash)}tryByDescriptor(t){return this.workspaceByIdent.has(t.identHash)?this.workspaceByIdent.get(t.identHash):this.notExternal.has(t.identHash)||this.project.tryWorkspaceByDescriptor(t)?null:this.tryIdentLoad(t)}findByDescriptor(t){let e=this.tryByDescriptor(t);if(!e)throw new Error(`Cannot find workspace for descriptor ${v.structUtils.stringifyDescriptor(t)}`);return e}tryByLocator(t){return this.workspaceByIdent.has(t.identHash)?this.workspaceByIdent.get(t.identHash):this.notExternal.has(t.identHash)||this.project.tryWorkspaceByLocator(t)?null:this.tryIdentLoad(t)}findByLocator(t){let e=this.tryByLocator(t);if(!e)throw new Error(`Cannot find workspace for locator ${v.structUtils.stringifyLocator(t)}`);return e}getResolver(){return this.resolver??=this.project.configuration.makeResolver(),this.resolver}getFetcher(){return this.fetcher??=this.project.configuration.makeFetcher(),this.fetcher}},U=null;function w(r){return U||(U=new J(r)),U}var j=class r{constructor(){this.tracker=null}static{this.protocol=P}ensureTracker(t){return this.tracker||(this.tracker=w(t.project)),this.tracker}supports(t,e){return t.reference.startsWith(r.protocol)}getLocalPath(t,e){return this.ensureTracker(e).findByLocator(t).localPath||null}async fetch(t,e){let o=this.ensureTracker(e),s=o.findByLocator(t);if(s.localPath){let n=x.ppath.resolve(o.root,s.localPath);return{packageFs:new x.CwdFS(x.PortablePath.root),prefixPath:n,localPath:n}}return await this.fetchFallback(t,e,s)}async fetchFallback(t,e,o){let s=o.toFallbackLocator(t),a=await e.fetcher.fetch(s,e);return delete a.checksum,a}};var lt=i("@yarnpkg/fslib");var pt=i("@yarnpkg/cli"),L=i("@yarnpkg/core"),h=i("@yarnpkg/fslib"),g=i("clipanion"),O=C(i("fs"));var ct="1.0.0",$=class extends pt.BaseCommand{constructor(){super(...arguments);this.target=g.Option.String("--target","",{description:"The path to the file to output the workspaces to"});this.checkOnly=g.Option.Boolean("--check-only",!1,{description:"Check if the workspaces have changed without writing the file"});this.includePrivate=g.Option.Boolean("--include-private",!1,{description:"Include private workspaces in the output"})}static{this.paths=[["external-workspaces","output"]]}static{this.usage=g.Command.Usage({category:"External Workspaces",description:"Output current workspace information to a json file",details:`
      This command will output the current set of workspaces to a json file. The file will not be modified if the workspaces have not changed.

      The path to the .json file can optionally have a set of keys appended to the end as a path. This will write the workspaces to a subpath of
      the file while maintaining the other contents of the file.
    `,examples:[["Output workspaces with settings from package.json","$0 external-workspaces output"],["Output workspaces to target","$0 external-workspaces output --target ./path/to/file.json"],["Output workspaces to target with a subpath","$0 external-workspaces output --target ./path/to/file.json/key1/key2"],["Check if workspaces have changed","$0 external-workspaces output --target ./path/to/file.json --check-only"]]})}async execute(){let{quiet:e,stdout:o}=this.context,s=e?()=>null:u=>o.write(`${u}
`),n=await L.Configuration.find(this.context.cwd,this.context.plugins),a=y(n),{project:c}=await L.Project.find(n,this.context.cwd),l=this.target||a.outputPath;if(!l)throw new g.UsageError("No output path specified in configuration or command. Use --target to specify a path");H(c,h.npath.toPortablePath(l),this.checkOnly,s)}};function H(r,t,e,o){let s=t.endsWith(".json"),n=h.npath.fromPortablePath(s?h.ppath.dirname(t):t),a=s?h.ppath.basename(t):It(r);!e&&!O.default.existsSync(n)&&O.default.mkdirSync(n,{recursive:!0,mode:493});let c=h.npath.join(n,a),l={};for(let T of r.workspacesByIdent.values()){let{name:K,private:dt}=T.manifest;if(K&&!dt){let gt=L.structUtils.stringifyIdent(K);l[gt]=h.ppath.relative(r.cwd,T.cwd)}}let u=h.npath.relative(n,h.npath.fromPortablePath(r.cwd)),f={repoPath:u,version:ct,workspaces:Ct(l)},m=O.default.existsSync(c)?JSON.parse(O.default.readFileSync(c,"utf8")):{},d=m.generated||{},D=d.repoPath||"",A=bt(d.workspaces||{},l),ft=u!==D||d.version!==ct;if(A||ft)if(e)Tt(c,D,u,A,o);else{m.generated=f;let T=JSON.stringify(m,null,2);O.default.writeFileSync(c,T),o(`Updated workspaces in ${c}`)}}function Tt(r,t,e,o,s){if(s(`Updates needed for ${r}:`),t!==e&&s(`Repo path has changed from ${t} to ${e}`),o)for(let n in o){let a=String(o[n]).padEnd(6," ");s(`${a} - ${n}`)}}function bt(r,t){let e={},o=!1;for(let s in t){let n=r[s];n?n!==t[s]&&(e[s]="update",o=!0):(e[s]="add",o=!0)}for(let s in r)t[s]||(e[s]="remove",o=!0);return o?e:null}function Ct(r){return Object.fromEntries(Object.entries(r).sort())}function It(r){let e=r.workspacesByCwd.get(r.cwd)?.manifest.name;return e?`${e.scope?`@${e.scope}-${e.name}`:e.name}-workspaces.json`:"workspaces.json"}function ht(r,t){let e=y(r.configuration);if(!e.outputOnlyOnCommand&&e.outputPath){let o=s=>t.report.reportInfo(null,s);H(r,lt.npath.toPortablePath(e.outputPath),!1,o)}}async function ut(r,t,e,o,s){return w(t).tryByDescriptor(r)?.toLeadDescriptor(r)??r}var R=i("@yarnpkg/core");var B=class{constructor(t,e){this.tracker=null;this.resolverType=t,this.protocol=e}ensureTracker(t){return this.tracker||(this.tracker=w(t.project)),this.tracker}getResolutionDependencies(t,e){return this.ensureTracker(e).findByDescriptor(t).getResolutionDependencies(t,this.resolverType)}supportsDescriptor(t,e){return t.range.startsWith(this.protocol)}supportsLocator(t,e){return t.reference.startsWith(this.protocol)}shouldPersistResolution(t,e){return!1}bindDescriptor(t,e,o){return t}async getCandidates(t,e,o){return await this.ensureTracker(o).findByDescriptor(t).getCandidates(t,e,o,this.resolverType)}async getSatisfying(t,e,o,s){return await this.ensureTracker(s).findByDescriptor(t).getSatisfying(t,e,o,s,this.resolverType)}async resolve(t,e){let o=this.ensureTracker(e),s=`UNEXPECTED: resolve called for ${R.structUtils.stringifyLocator(t)} in ${this.resolverType} resolver`;throw o.trace(s),new Error(s)}},N=class r extends B{static{this.protocol=E}constructor(){super("remote",r.protocol)}},S=class r extends B{static{this.protocol=P}constructor(){super("local",r.protocol)}async resolve(t,e){return{...new R.Manifest,...t,version:"0.0.0",languageName:e.project.configuration.get("defaultLanguageName"),linkType:R.LinkType.SOFT}}};var Ft={configuration:Q,fetchers:[j],resolvers:[S,N],hooks:{afterAllInstalled:ht,reduceDependency:ut},commands:[$]},Wt=Ft;return xt(Et);})();
return plugin;
}
};
//# sourceMappingURL=external-workspaces.cjs.map
