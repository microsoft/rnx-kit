import {
  type Descriptor,
  LinkType,
  type Locator,
  Manifest,
  MessageName,
  type MinimalResolveOptions,
  miscUtils,
  type Package,
  ReportError,
  type ResolveOptions,
  type Resolver,
  semverUtils,
  structUtils,
} from "@yarnpkg/core";
import semver from "semver";

import { npmHttpUtils, NpmSemverFetcher } from "@yarnpkg/plugin-npm";
import { type ExternalWorkspaceTracker, getWorkspaceTracker } from "./tracker";
import {
  getFallbackProtocol,
  toExternalDescriptor,
  toNpmDescriptor,
} from "./utilities";

const NODE_GYP_IDENT = structUtils.makeIdent(null, `node-gyp`);
const NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;
const PROTOCOL = getFallbackProtocol();

export class FallbackResolver implements Resolver {
  static protocol = getFallbackProtocol();
  private tracker: ExternalWorkspaceTracker | null = null;

  /**
   * Ensure a finder is created if it is not already present, then return it
   */
  private ensureTracker(opts: MinimalResolveOptions) {
    if (!this.tracker) {
      this.tracker = getWorkspaceTracker(opts.project);
    }
    return this.tracker;
  }

  supportsDescriptor(descriptor: Descriptor, _opts: MinimalResolveOptions) {
    if (!descriptor.range.startsWith(PROTOCOL)) {
      return false;
    }

    return !!semverUtils.validRange(descriptor.range.slice(PROTOCOL.length));
  }

  supportsLocator(locator: Locator, _opts: MinimalResolveOptions) {
    if (!locator.reference.startsWith(PROTOCOL)) {
      return false;
    }

    const { selector } = structUtils.parseRange(locator.reference);
    if (!semver.valid(selector)) {
      return false;
    }

    return true;
  }

  shouldPersistResolution(_locator: Locator, _opts: MinimalResolveOptions) {
    return true;
  }

  bindDescriptor(
    descriptor: Descriptor,
    _fromLocator: Locator,
    _opts: MinimalResolveOptions
  ) {
    return descriptor;
  }

  getResolutionDependencies(
    descriptor: Descriptor,
    opts: MinimalResolveOptions
  ) {
    const workspace = this.ensureTracker(opts).findByDescriptor(descriptor);
    // if this is local, this protocol has already been added by the external protocol so only the npm one is needed
    if (!workspace.localPath) {
      return {
        externalRef: toExternalDescriptor(descriptor),
      } as Record<string, Descriptor>;
    }
    return {};
  }

  async getCandidates(
    descriptor: Descriptor,
    _dependencies: Record<string, Package>,
    opts: ResolveOptions
  ) {
    const npmDescriptor = toNpmDescriptor(descriptor);
    const range = semverUtils.validRange(
      descriptor.range.slice(PROTOCOL.length)
    );
    if (range === null)
      throw new Error(
        `Expected a valid range, got ${descriptor.range.slice(PROTOCOL.length)}`
      );

    const registryData = await npmHttpUtils.getPackageMetadata(npmDescriptor, {
      cache: opts.fetchOptions?.cache,
      project: opts.project,
      version: semver.valid(range.raw) ? range.raw : undefined,
    });

    const candidates = miscUtils.mapAndFilter(
      Object.keys(registryData.versions),
      (version) => {
        try {
          const candidate = new semverUtils.SemVer(version);
          if (range.test(candidate)) {
            return candidate;
          }
        } catch {
          /* empty */
        }

        return miscUtils.mapAndFilter.skip;
      }
    );

    const noDeprecatedCandidates = candidates.filter((version) => {
      return !registryData.versions[version.raw].deprecated;
    });

    // If there are versions that aren't deprecated, use them
    const finalCandidates =
      noDeprecatedCandidates.length > 0 ? noDeprecatedCandidates : candidates;

    finalCandidates.sort((a, b) => {
      return -a.compare(b);
    });

    return finalCandidates.map((version) => {
      const versionLocator = structUtils.makeLocator(
        npmDescriptor,
        `${PROTOCOL}${version.raw}`
      );
      const archiveUrl = registryData.versions[version.raw].dist.tarball;

      if (
        NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {
          configuration: opts.project.configuration,
        })
      ) {
        return versionLocator;
      } else {
        return structUtils.bindLocator(versionLocator, {
          __archiveUrl: archiveUrl,
        });
      }
    });
  }

  async getSatisfying(
    descriptor: Descriptor,
    _dependencies: Record<string, Package>,
    locators: Locator[],
    _opts: ResolveOptions
  ) {
    const range = semverUtils.validRange(
      descriptor.range.slice(PROTOCOL.length)
    );
    if (range === null)
      throw new Error(
        `Expected a valid range, got ${descriptor.range.slice(PROTOCOL.length)}`
      );

    const results = miscUtils.mapAndFilter(locators, (locator) => {
      if (locator.identHash !== descriptor.identHash)
        return miscUtils.mapAndFilter.skip;

      const parsedRange = structUtils.tryParseRange(locator.reference, {
        requireProtocol: PROTOCOL,
      });
      if (!parsedRange) return miscUtils.mapAndFilter.skip;

      const version = new semverUtils.SemVer(parsedRange.selector);
      if (!range.test(version)) return miscUtils.mapAndFilter.skip;

      return { locator, version };
    });

    const sortedResults = results
      .sort((a, b) => -a.version.compare(b.version))
      .map(({ locator }) => locator);

    return {
      locators: sortedResults,
      sorted: true,
    };
  }

  async resolve(locator: Locator, opts: ResolveOptions) {
    const { selector } = structUtils.parseRange(locator.reference);

    const version = semverUtils.clean(selector);
    if (version === null)
      throw new ReportError(
        MessageName.RESOLVER_NOT_FOUND,
        `The npm semver resolver got selected, but the version isn't semver`
      );

    const registryData = await npmHttpUtils.getPackageMetadata(locator, {
      cache: opts.fetchOptions?.cache,
      project: opts.project,
      version,
    });

    const manifest = new Manifest();
    manifest.load(registryData.versions[version]);

    // Manually add node-gyp dependency if there is a script using it and not already set
    // This is because the npm registry will automatically add a `node-gyp rebuild` install script
    // in the metadata if there is not already an install script and a binding.gyp file exists.
    // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.
    if (
      !manifest.dependencies.has(NODE_GYP_IDENT.identHash) &&
      !manifest.peerDependencies.has(NODE_GYP_IDENT.identHash)
    ) {
      for (const value of manifest.scripts.values()) {
        if (value.match(NODE_GYP_MATCH)) {
          manifest.dependencies.set(
            NODE_GYP_IDENT.identHash,
            structUtils.makeDescriptor(NODE_GYP_IDENT, `latest`)
          );
          break;
        }
      }
    }

    return {
      ...locator,

      version,

      languageName: `node`,
      linkType: LinkType.HARD,

      conditions: manifest.getConditions(),

      dependencies: opts.project.configuration.normalizeDependencyMap(
        manifest.dependencies
      ),
      peerDependencies: manifest.peerDependencies,

      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,

      bin: manifest.bin,
    };
  }
}
